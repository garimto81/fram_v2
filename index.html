<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 - Ver 1.2.0 (로직 개선)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; scroll-behavior: smooth; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-item:hover { background-color: #f0f9ff; }
        .result-item.selected { background-color: #dbeafe; }
        .result-item.locked { background-color: #f1f5f9; opacity: 0.6; cursor: not-allowed; }
        .result-item.locked:hover { background-color: #f1f5f9; }
        #custom-modal-overlay, #upload-test-modal-overlay, #review-modal-overlay { background-color: rgba(0, 0, 0, 0.5); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="relative text-center mb-8 py-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">
                포커스 이슈 탐지기
                <span id="version-display" class="text-base align-middle text-blue-600 font-semibold"></span>
            </h1>
            <p id="connection-status" class="text-sm text-gray-500 mt-1">연결 상태: 확인 중...</p>
            <p id="model-status" class="text-sm text-yellow-600 mt-1">인식 모델 로딩 중...</p>
            <div class="absolute top-4 right-4">
                <button id="show-upload-test-btn" class="text-sm bg-gray-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-gray-600 transition">연결 테스트</button>
            </div>
        </header>
        
        <main class="space-y-8">
            <!-- Control Panel -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 제어 패널</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <div>
                        <label for="video-files-input" class="block text-sm font-medium text-gray-700 mb-1">영상 파일 선택</label>
                        <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                    </div>
                     <div class="space-y-2">
                        <label for="threshold-slider" class="block text-sm font-medium text-gray-700">흐림 기준값 (낮을수록 민감)</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span id="threshold-value" contenteditable="true" class="font-bold text-lg text-blue-600 w-16 text-center cursor-text focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md px-1">50</span>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <label for="review-before-upload-checkbox" class="flex items-center text-sm font-medium text-gray-700 cursor-pointer">
                        <input type="checkbox" id="review-before-upload-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                        <span class="ml-2">업로드 전 검토하기</span>
                    </label>
                </div>
                <div class="mt-6 text-center">
                     <button id="analyze-button" class="w-full md:w-auto bg-green-600 text-white font-bold py-3 px-12 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        분석 시작
                    </button>
                    <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center">
                        <div class="loader"></div>
                        <p id="progress-text" class="text-gray-600 mt-2"></p>
                        <div id="upload-progress-container" class="w-full mt-4 hidden">
                             <div class="w-full bg-gray-200 rounded-full h-4">
                                 <div id="upload-progress-bar" class="bg-blue-600 h-4 rounded-full text-xs font-medium text-white text-center leading-4 transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <button id="cancel-upload-btn" class="hidden mt-4 bg-red-600 text-white font-bold py-2 px-6 rounded-full hover:bg-red-700 transition">
                            분석 중단
                        </button>
                    </div>
                </div>
            </div>

            <!-- Analysis History -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 기록</h2>
                 <div id="results-list-container" class="space-y-1">
                     <p id="results-list-placeholder" class="text-gray-500 text-center py-4">인증이 완료되면 기록을 불러옵니다...</p>
                 </div>
                 <div id="pagination-controls" class="pt-4 mt-4 border-t flex justify-center gap-2"></div>
            </div>

            <!-- Details Section -->
            <div id="details-section" class="hidden space-y-8">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                      <h2 id="details-title" class="text-xl font-semibold mb-4 border-b pb-2 flex justify-between items-center">
                        <span>3. 상세 분석 그래프</span>
                        <button id="export-csv-btn" class="text-sm bg-blue-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-blue-600 transition">CSV로 내보내기</button>
                      </h2>
                      <p class="text-sm text-gray-600 mb-2 -mt-2">그래프 위 빨간 점에 마우스를 올리면 주요 프레임을 확인할 수 있습니다.</p>
                      <div id="chart-container" class="relative h-48 md:h-64">
                          <canvas id="detail-chart"></canvas>
                      </div>
                </div>
                 <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 border-b pb-2">4. 주요 프레임 보기</h2>
                    <div id="key-frames-container" class="space-y-4">
                        <p id="key-frames-placeholder" class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없거나, 아직 기록이 선택되지 않았습니다.</p>
                    </div>
                </div>
            </div>
            
            <!-- Log Container -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">실시간 분석 로그</h2>
                <div id="log-container" class="min-h-[10rem] max-h-[50rem] overflow-y-auto bg-gray-900 text-white font-mono rounded-lg p-4 border text-sm"><p id="log-placeholder" class="text-gray-400 text-center py-4">분석을 시작하거나 과거 기록을 선택하면 로그가 표시됩니다.</p></div>
            </div>
        </main>
    </div>

    <!-- Pre-upload Review Modal -->
    <div id="review-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-4xl transform transition-transform duration-300 scale-95 flex flex-col h-[90vh]">
            <div class="flex justify-between items-center mb-4 border-b pb-3">
                <h3 class="text-lg font-bold text-gray-900">업로드 전 검토</h3>
                <button id="close-review-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <p class="text-sm text-gray-600 mb-4">업로드할 문제 프레임을 선택하세요. 선택 해제된 항목은 서버에 저장되지 않습니다.</p>
            <div id="review-frames-list" class="flex-grow overflow-y-auto space-y-4 pr-2">
                <!-- Review frames will be dynamically inserted here -->
            </div>
            <div class="mt-6 flex justify-end space-x-3 border-t pt-4">
                <button id="review-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">전체 취소</button>
                <button id="review-confirm-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">선택한 프레임 업로드</button>
            </div>
        </div>
    </div>

    <!-- Upload Test Modal -->
    <div id="upload-test-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="upload-test-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-lg transform transition-transform duration-300 scale-95">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-900">Firebase 연결 테스트</h3>
                <button id="close-test-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <h4 class="font-semibold mb-2">1. Storage 업로드 테스트</h4>
                    <input type="file" id="test-file-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer mb-2"/>
                    <button id="start-storage-test-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700 transition">Storage 테스트 시작</button>
                </div>
                 <div class="border-t my-4"></div>
                <div>
                    <h4 class="font-semibold mb-2">2. Firestore 쓰기 테스트</h4>
                    <button id="start-firestore-test-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-full hover:bg-indigo-700 transition">Firestore 테스트 시작</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Modal for Confirmation -->
    <div id="custom-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="custom-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-md transform transition-transform duration-300 scale-95">
            <h3 id="modal-title" class="text-lg font-bold text-gray-900">확인</h3>
            <p id="modal-message" class="mt-2 text-sm text-gray-600">이 작업을 정말로 수행하시겠습니까?</p>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">취소</button>
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">확인</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase 11.x SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        const APP_VERSION = "1.2.0";
        document.title = `포커스 이슈 탐지기 - Ver ${APP_VERSION}`;
        document.getElementById('version-display').textContent = `Ver ${APP_VERSION}`;
        
        // --- DOM References ---
        const connectionStatus = document.getElementById('connection-status');
        const modelStatus = document.getElementById('model-status');
        const videoFilesInput = document.getElementById('video-files-input');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdValueEl = document.getElementById('threshold-value');
        const reviewBeforeUploadCheckbox = document.getElementById('review-before-upload-checkbox');
        const analyzeButton = document.getElementById('analyze-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressText = document.getElementById('progress-text');
        const uploadProgressContainer = document.getElementById('upload-progress-container');
        const uploadProgressBar = document.getElementById('upload-progress-bar');
        const cancelUploadBtn = document.getElementById('cancel-upload-btn');
        const resultsListContainer = document.getElementById('results-list-container');
        const resultsListPlaceholder = document.getElementById('results-list-placeholder');
        const paginationControls = document.getElementById('pagination-controls');
        const detailsSection = document.getElementById('details-section');
        const detailsTitle = document.getElementById('details-title');
        const detailChartCanvas = document.getElementById('detail-chart');
        const logContainer = document.getElementById('log-container');
        const keyFramesContainer = document.getElementById('key-frames-container');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const showUploadTestBtn = document.getElementById('show-upload-test-btn');
        // Test Modal
        const uploadTestModalOverlay = document.getElementById('upload-test-modal-overlay');
        const closeTestModalBtn = document.getElementById('close-test-modal-btn');
        const testFileInput = document.getElementById('test-file-input');
        const startStorageTestBtn = document.getElementById('start-storage-test-btn');
        const startFirestoreTestBtn = document.getElementById('start-firestore-test-btn');
        // Review Modal
        const reviewModalOverlay = document.getElementById('review-modal-overlay');
        const reviewFramesList = document.getElementById('review-frames-list');
        const closeReviewModalBtn = document.getElementById('close-review-modal-btn');
        const reviewCancelBtn = document.getElementById('review-cancel-btn');
        const reviewConfirmBtn = document.getElementById('review-confirm-btn');


        // --- Global State ---
        let videoFiles = [];
        let modelsLoaded = false;
        const MODEL_URL = 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights';
        let allAnalysisData = [];
        let detailChart = null;
        let currentPage = 1;
        const ITEMS_PER_PAGE = 20;
        let analysisController = null; // To control cancellation
        let currentLockedDocId = null;
        const LOCK_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes

        // --- Firebase State ---
        let app, auth, db, storage;
        let unsubscribeFromAnalyses = null;

        // --- UI & Log Functions ---
        function appendLog(message, colorClass = 'text-gray-400', source = 'APP') {
            if (logContainer.querySelector("#log-placeholder")) logContainer.innerHTML = '';
            const logEntry = document.createElement('div');
            const prefix = `[${source}]`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${prefix} ${message}`;
            logEntry.className = colorClass;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function appendImageLog(data) {
            const logEntry = document.createElement('div');
            logEntry.className = 'p-2 my-2 border border-gray-700 rounded-md';
            const sharpScoreText = data.sharpScore !== null ? data.sharpScore.toFixed(2) : 'N/A';
            const blurryScoreText = data.blurryScore !== null ? data.blurryScore.toFixed(2) : 'N/A';

            logEntry.innerHTML = `
                <p class="text-sm font-semibold text-yellow-400">문제 프레임 감지 @ ${data.time.toFixed(2)}초</p>
                <div class="grid grid-cols-2 gap-2 mt-1">
                    <div>
                        <p class="text-xs text-green-400 mb-1">이전 프레임 (전체) - 점수: ${sharpScoreText}</p>
                        <img src="${data.sharpFull}" class="w-full rounded">
                    </div>
                    <div>
                        <p class="text-xs text-green-400 mb-1">이전 프레임 (얼굴)</p>
                        <img src="${data.sharpCropped || 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face'}" class="w-full rounded">
                    </div>
                    <div>
                        <p class="text-xs text-red-400 mb-1">문제 프레임 (전체) - 점수: ${blurryScoreText}</p>
                        <img src="${data.blurryFull}" class="w-full rounded">
                    </div>
                   <div>
                        <p class="text-xs text-red-400 mb-1">문제 프레임 (얼굴)</p>
                        <img src="${data.blurryCropped || 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face'}" class="w-full rounded">
                    </div>
                </div>
            `;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // --- Modal Logic ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modal = document.getElementById('custom-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        let modalResolve = null;
        let reviewModalResolve = null;

        function showConfirmationModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('scale-95'), 10);
            return new Promise(resolve => { modalResolve = resolve; });
        }

        function closeModal(result) {
            modal.classList.add('scale-95');
            setTimeout(() => modalOverlay.classList.add('hidden'), 300);
            if (modalResolve) { modalResolve(result); modalResolve = null; }
        }
        modalCancelBtn.addEventListener('click', () => closeModal(false));
        modalConfirmBtn.addEventListener('click', () => closeModal(true));
        modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) closeModal(false); });

        function handleCloseReviewModal(confirmed) {
            reviewModalOverlay.classList.add('hidden');
            if (!reviewModalResolve) return;

            if (!confirmed) {
                reviewModalResolve(null); // Cancelled
            } else {
                const selectedIndices = [];
                const frameElements = reviewFramesList.querySelectorAll('.review-frame-item');
                frameElements.forEach(el => {
                    const checkbox = el.querySelector('input[type="checkbox"]');
                    if (checkbox.checked) {
                        selectedIndices.push(parseInt(el.dataset.frameIndex, 10));
                    }
                });
                reviewModalResolve(selectedIndices);
            }
            reviewModalResolve = null;
        }

        function showReviewModal(keyFrames) {
            reviewFramesList.innerHTML = ''; // Clear previous content
            keyFrames.forEach((frame, index) => {
                const item = document.createElement('div');
                item.className = 'review-frame-item p-3 border rounded-lg bg-gray-50';
                item.dataset.frameIndex = index;
                item.innerHTML = `
                    <div class="flex items-start gap-4">
                        <input type="checkbox" id="review-check-${index}" class="mt-1 h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                        <label for="review-check-${index}" class="flex-grow cursor-pointer">
                            <p class="font-semibold">문제 감지 @ ${frame.time.toFixed(2)}초</p>
                            <p class="text-xs text-gray-500">이전 프레임 점수: ${frame.sharpScore?.toFixed(2) ?? 'N/A'} &rarr; 문제 프레임 점수: ${frame.blurryScore?.toFixed(2) ?? 'N/A'}</p>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-2">
                                <img src="${frame.sharpFull}" class="w-full rounded border" title="이전 프레임 (전체)">
                                <img src="${frame.sharpCropped || 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face'}" class="w-full rounded border" title="이전 프레임 (얼굴)">
                                <img src="${frame.blurryFull}" class="w-full rounded border" title="문제 프레임 (전체)">
                                <img src="${frame.blurryCropped || 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face'}" class="w-full rounded border" title="문제 프레임 (얼굴)">
                            </div>
                        </label>
                    </div>
                `;
                reviewFramesList.appendChild(item);
            });

            reviewModalOverlay.classList.remove('hidden');
            return new Promise(resolve => { reviewModalResolve = resolve; });
        }
        closeReviewModalBtn.addEventListener('click', () => handleCloseReviewModal(false));
        reviewCancelBtn.addEventListener('click', () => handleCloseReviewModal(false));
        reviewConfirmBtn.addEventListener('click', () => handleCloseReviewModal(true));

        // --- Locking Mechanism ---
        async function releaseLock(docId) {
            if (!docId) return;
            const docRef = doc(db, `public_data/shared_documents/analyses`, docId);
            try {
                await updateDoc(docRef, { lock: null });
                appendLog(`잠금 해제: ${docId}`, 'text-gray-500');
            } catch (error) {
                console.error(`Failed to release lock for ${docId}:`, error);
            }
        }

        async function releaseCurrentLock() {
            if (currentLockedDocId) {
                await releaseLock(currentLockedDocId);
                currentLockedDocId = null;
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (currentLockedDocId) {
                releaseLock(currentLockedDocId);
            }
        });

        // --- Initialization & Firebase Connection Management ---
        async function startApp() {
            appendLog('앱 시작...', 'text-white');
            
            const firebaseConfig = {
                apiKey: "AIzaSyAyTh3kG9pPcgqcs-MHXSBKFgY_gnRWae0",
                authDomain: "analyze-frame-focus.firebaseapp.com",
                projectId: "analyze-frame-focus",
                storageBucket: "analyze-frame-focus.firebasestorage.app",
                messagingSenderId: "995861796391",
                appId: "1:995861796391:web:549944764ca046594c2002",
                measurementId: "G-8GCL3Z7W9C"
            };
            
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
                
                connectionStatus.textContent = `연결 상태: 연결 성공 (${firebaseConfig.projectId})`;
                connectionStatus.className = 'text-sm text-green-600 mt-1';
                appendLog(`Firebase 연결 성공 (Project: ${firebaseConfig.projectId})`, 'text-green-500');

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        appendLog(`인증 완료 (UID: ${user.uid})`, 'text-green-500');
                        if (unsubscribeFromAnalyses) unsubscribeFromAnalyses();
                        listenForDataChanges();
                    } else {
                        await signInAnonymously(auth);
                    }
                });

            } catch (e) {
                connectionStatus.textContent = '오류: Firebase 초기화 실패.';
                connectionStatus.className = 'text-sm text-red-600 mt-1';
                appendLog(`Firebase 초기화 오류: ${e.message}`, 'text-red-500');
                analyzeButton.disabled = true;
            }

            const savedThreshold = localStorage.getItem('focusThreshold') || '50';
            updateThreshold(savedThreshold, false); // Don't save on initial load

            await loadFaceApiModels();
        }
        
        async function loadFaceApiModels() {
            if (modelsLoaded) return;
            try {
                // Use the more accurate SsdMobilenetv1 model
                await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
                modelsLoaded = true;
                modelStatus.textContent = '얼굴 인식 모델 로딩 완료!';
                modelStatus.className = 'text-sm text-green-600 mt-1';
                updateAnalyzeButtonState();
            } catch (error) {
                modelStatus.textContent = '모델 로딩 실패';
                appendLog(`모델 로딩 실패: ${error.message}`, 'text-red-500');
            }
        }
        
        function listenForDataChanges() {
            const analysesColPath = `public_data/shared_documents/analyses`;
            unsubscribeFromAnalyses = onSnapshot(collection(db, analysesColPath), (snapshot) => {
                allAnalysisData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                allAnalysisData.sort((a, b) => (b.timestamp?.seconds ?? 0) - (a.timestamp?.seconds ?? 0));
                renderAnalysisResultsList();
            }, (error) => {
                appendLog(`DB 데이터 수신 오류: ${error.code} - ${error.message}`, 'text-red-500');
            });
        }

        function updateAnalyzeButtonState() { 
            analyzeButton.disabled = videoFiles.length === 0 || !modelsLoaded; 
        }

        // --- Helper Function to convert Data URL to Blob ---
        function dataURLtoBlob(dataurl) {
            if (!dataurl) return null;
            const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type:mime});
        }

        // --- Core Logic & Render Functions ---
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData;
            if (width === 0 || height === 0) return 0;
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            let laplacianMean = 0;
            const laplacianValues = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;
                    const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                    laplacianValues.push(laplacian);
                    laplacianMean += laplacian;
                }
            }
            if (laplacianValues.length === 0) return 0;
            laplacianMean /= laplacianValues.length;
            const variance = laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
            return variance;
        }

        /**
         * Selects the best face from detections based on size and centrality.
         * @param {Array} detections - Array of face detections from face-api.
         * @param {number} videoWidth - The width of the video frame.
         * @param {number} videoHeight - The height of the video frame.
         * @returns {object|null} The best face detection object or null.
         */
        function getBestFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null;
            if (detections.length === 1) return detections[0];

            const frameCenterX = videoWidth / 2;
            const frameCenterY = videoHeight / 2;

            const scoredDetections = detections.map(detection => {
                const { box } = detection;
                const area = box.width * box.height;
                const faceCenterX = box.x + box.width / 2;
                const faceCenterY = box.y + box.height / 2;
                const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2));
                return { detection, area, distance };
            });

            const maxArea = Math.max(...scoredDetections.map(d => d.area));
            const maxDistance = Math.max(...scoredDetections.map(d => d.distance));

            const safeMaxArea = maxArea === 0 ? 1 : maxArea;
            const safeMaxDistance = maxDistance === 0 ? 1 : maxDistance;

            let bestDetection = null;
            let maxScore = -1;

            for (const item of scoredDetections) {
                const sizeScore = item.area / safeMaxArea;
                const distanceScore = 1 - (item.distance / safeMaxDistance);

                // Weights: 60% for size, 40% for centrality
                const finalScore = (sizeScore * 0.6) + (distanceScore * 0.4);

                if (finalScore > maxScore) {
                    maxScore = finalScore;
                    bestDetection = item.detection;
                }
            }
            
            return bestDetection;
        }

        function getCroppedFaceDataURL(canvas, box) {
            if (!box) return null;
            const { x, y, width, height } = box;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
            return tempCanvas.toDataURL('image/jpeg', 0.8);
        }

        function renderAnalysisResultsList() {
            resultsListPlaceholder.classList.add('hidden');
            resultsListContainer.innerHTML = '';
            
            if (allAnalysisData.length === 0) {
                resultsListPlaceholder.textContent = '저장된 분석 기록이 없습니다.';
                resultsListPlaceholder.classList.remove('hidden');
                paginationControls.innerHTML = '';
                return;
            }

            const totalPages = Math.ceil(allAnalysisData.length / ITEMS_PER_PAGE);
            currentPage = Math.min(currentPage, totalPages);
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const paginatedData = allAnalysisData.slice(startIndex, startIndex + ITEMS_PER_PAGE);

            paginatedData.forEach((data) => {
                const item = document.createElement('div');
                const dateString = data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString() : '날짜 없음';
                const problemCount = (data.keyFrames || []).filter(kf => kf.manualOverride !== 'ok').length;
                
                const lock = data.lock;
                const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > LOCK_TIMEOUT_MS;
                const isLocked = lock && !isStale;
                const isLockedByCurrentUser = isLocked && lock.lockedBy === auth.currentUser.uid;
                const isLockedByOther = isLocked && !isLockedByCurrentUser;

                item.className = `result-item p-3 border-b flex justify-between items-center transition-colors duration-200`;
                if (isLockedByOther) item.classList.add('locked');
                if (isLockedByCurrentUser) item.classList.add('selected');

                item.dataset.analysisId = data.id;

                let lockIcon = '';
                if (isLockedByOther) {
                    lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-gray-500 mr-2" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg>`;
                } else if (isLockedByCurrentUser) {
                    lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-blue-600 mr-2" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8m1.173-1.173a14.3 14.3 0 0 1 1.66-2.043C4.12 3.4 5.88 2.5 8 2.5s3.879.9 5.168 2.287a14.3 14.3 0 0 1 1.66 2.043A14.3 14.3 0 0 1 16 8s-.9 1.88-2.287 3.173a14.3 14.3 0 0 1-1.66 2.043C11.879 14.6 10.12 15.5 8 15.5s-3.879-.9-5.168-2.287a14.3 14.3 0 0 1-1.66-2.043A14.3 14.3 0 0 1 0 8s.9-1.88 2.287-3.173Z"/></svg>`;
                }
                
                item.innerHTML = `
                    <div class="flex-grow overflow-hidden flex items-center">
                        ${lockIcon}
                        <div>
                            <p class="font-medium text-gray-800 truncate text-sm" title="${data.fileName}">${data.fileName}</p>
                            <p class="text-xs text-gray-500">${dateString}</p>
                        </div>
                    </div>
                    <div class="flex items-center ml-2">
                        <div class="text-sm font-semibold ${problemCount > 0 ? 'text-red-500' : 'text-green-600'} w-28 text-right">문제 프레임: ${problemCount}개</div>
                        <button class="delete-analysis-button ml-4 text-gray-400 hover:text-red-600 p-2 rounded-full hover:bg-red-100 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" class="pointer-events-none">
                                <path d="M11 1.5v1h3.5a.5.5 0 0 1 0 1h-.538l-.853 10.66A2 2 0 0 1 11.115 16h-6.23a2 2 0 0 1-1.994-1.84L2.038 3.5H1.5a.5.5 0 0 1 0-1H5v-1A1.5 1.5 0 0 1 6.5 0h3A1.5 1.5 0 0 1 11 1.5m-5 0v1h4v-1a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5M4.5 5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5-.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06"/>
                            </svg>
                        </button>
                    </div>`;
                resultsListContainer.appendChild(item);
            });

            renderPagination(Math.ceil(allAnalysisData.length / ITEMS_PER_PAGE));
        }

        resultsListContainer.addEventListener('click', async (e) => {
            const resultItem = e.target.closest('.result-item');
            if (!resultItem) return;

            if (resultItem.classList.contains('locked')) {
                appendLog('다른 사용자가 사용 중인 항목입니다.', 'text-yellow-400');
                return;
            }

            const analysisId = resultItem.dataset.analysisId;

            if (e.target.closest('.delete-analysis-button')) {
                e.stopPropagation();
                handleDeleteAnalysis(analysisId);
                return;
            }

            if (analysisId === currentLockedDocId) return; // Already selected

            await releaseCurrentLock();
            
            const docRef = doc(db, `public_data/shared_documents/analyses`, analysisId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(docRef);
                    if (!sfDoc.exists()) {
                        throw "Document does not exist!";
                    }

                    const data = sfDoc.data();
                    const lock = data.lock;
                    const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > LOCK_TIMEOUT_MS;
                    
                    if (lock && !isStale && lock.lockedBy !== auth.currentUser.uid) {
                        throw new Error("다른 사용자가 방금 이 항목을 잠갔습니다.");
                    }

                    transaction.update(docRef, { 
                        lock: {
                            lockedBy: auth.currentUser.uid,
                            lockedAt: serverTimestamp()
                        }
                    });
                });

                currentLockedDocId = analysisId;
                appendLog(`항목 잠금 성공: ${analysisId}`, 'text-green-400');
                renderDetailedViewContent(analysisId);

            } catch (error) {
                appendLog(`항목을 잠글 수 없습니다: ${error.message}`, 'text-red-500');
                console.error("Locking failed: ", error);
            }
        });
        
        function renderPagination(totalPages) {
            paginationControls.innerHTML = '';
            if (totalPages <= 1) return;
            for (let i = 1; i <= totalPages; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = `px-3 py-1 rounded-md text-sm transition-colors ${i === currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`;
                button.onclick = () => { currentPage = i; renderAnalysisResultsList(); };
                paginationControls.appendChild(button);
            }
        }

        function highlightKeyFrame(time) {
            removeKeyFrameHighlight(); 
            const targetElement = document.querySelector(`#key-frames-container > div[data-time="${time}"]`);
            if (targetElement) {
                targetElement.classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function removeKeyFrameHighlight() {
            const highlighted = document.querySelector('.ring-2');
            if (highlighted) {
                highlighted.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
            }
        }

        function renderDetailedViewContent(analysisId) {
            detailsSection.classList.remove('hidden');
            const resultData = allAnalysisData.find(d => d.id === analysisId);
            if (!resultData) return;
            detailsTitle.textContent = `상세 분석: ${resultData.fileName}`;

            if (detailChart) { detailChart.destroy(); }
            
            const frameScores = resultData.frameScores || [];
            const keyFrames = resultData.keyFrames || [];

            const blurryPoints = keyFrames.filter(kf => kf.manualOverride !== 'ok').map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));
            const okPoints = keyFrames.filter(kf => kf.manualOverride === 'ok').map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));

            detailChart = new Chart(detailChartCanvas, {
                type: 'line',
                data: {
                    datasets: [
                        { label: '선명도', data: frameScores.map(fs => ({x: fs.time, y: fs.score})), borderColor: 'rgba(59, 130, 246, 0.5)', borderWidth: 1.5, pointRadius: 0, tension: 0.4 },
                        { label: '흐림 감지', data: blurryPoints, backgroundColor: 'rgb(239, 68, 68)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' },
                        { label: '수동 확인 (OK)', data: okPoints, backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { title: { display: true, text: '선명도 점수' } } },
                    plugins: { legend: { position: 'top' }, tooltip: { enabled: true } },
                    onHover: (event, chartElement) => {
                        const canvas = detailChartCanvas;
                        canvas.style.cursor = 'default';
                        removeKeyFrameHighlight();

                        if (chartElement.length > 0) {
                            const element = chartElement[0];
                            const datasetIndex = element.datasetIndex;
                            const index = element.index;
                            
                            if (datasetIndex === 1 || datasetIndex === 2) {
                                canvas.style.cursor = 'pointer';
                                const timeValue = detailChart.data.datasets[datasetIndex].data[index].x;
                                highlightKeyFrame(timeValue);
                            }
                        }
                    },
                }
            });

            renderKeyFramesForDetail(resultData);
            detailsSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        function renderKeyFramesForDetail(resultData) {
            keyFramesContainer.innerHTML = '';
            const keyFrames = resultData.keyFrames || [];
            
            if (keyFrames.length === 0) {
                keyFramesContainer.innerHTML = `<p class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없습니다.</p>`;
                return;
            }

            keyFrames.sort((a, b) => a.time - b.time).forEach(data => {
                const isOverridden = data.manualOverride === 'ok';
                const sharpScoreText = data.sharpScore !== null && data.sharpScore !== undefined ? data.sharpScore.toFixed(2) : 'N/A';
                const blurryScoreText = data.blurryScore !== null && data.blurryScore !== undefined ? data.blurryScore.toFixed(2) : 'N/A';

                const pairContainer = document.createElement('div');
                pairContainer.className = 'p-4 bg-gray-50 rounded-lg shadow-inner border space-y-4 transition-all duration-300';
                pairContainer.dataset.time = data.time;

                pairContainer.innerHTML = `
                    <h4 class="font-bold text-md">@ ${data.time.toFixed(2)}초</h4>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <p class="text-xs font-semibold text-green-600 mb-1">이전 프레임 (전체) - 점수: ${sharpScoreText}</p>
                            <img src="${data.sharpFullUrl}" class="w-full rounded-md border" loading="lazy">
                            <p class="text-xs font-semibold text-green-600 mt-2 mb-1">이전 프레임 (얼굴)</p>
                            <img src="${data.sharpCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy">
                        </div>
                        <div>
                            <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mb-1">문제 프레임 (전체) - 점수: ${blurryScoreText}</p>
                            <img src="${data.blurryFullUrl}" class="w-full rounded-md border" loading="lazy">
                            <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mt-2 mb-1">문제 프레임 (얼굴)</p>
                            <img src="${data.blurryCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy">
                        </div>
                    </div>
                    <button data-analysis-id="${resultData.id}" data-time="${data.time}" data-action="ok" class="manual-override-button w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm ${isOverridden ? 'hidden' : ''}">이 프레임은 문제 없음</button>
                    <button data-analysis-id="${resultData.id}" data-time="${data.time}" data-action="problem" class="manual-override-button w-full px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 text-sm ${!isOverridden ? 'hidden' : ''}">문제 프레임으로 되돌리기</button>
                `;
                keyFramesContainer.appendChild(pairContainer);
            });

            keyFramesContainer.querySelectorAll('.manual-override-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const { analysisId, time, action } = e.currentTarget.dataset;
                    handleManualCorrection(analysisId, parseFloat(time), action);
                });
            });
        }

        async function handleManualCorrection(analysisId, time, action) {
            const docRef = doc(db, `public_data/shared_documents/analyses`, analysisId);
            const docData = allAnalysisData.find(d => d.id === analysisId);
            if (!docData) return;

            const updatedKeyFrames = docData.keyFrames.map(kf => {
                if (kf.time === time) {
                    return action === 'ok' ? { ...kf, manualOverride: 'ok' } : (({ manualOverride, ...rest }) => rest)(kf);
                }
                return kf;
            });

            try {
                await updateDoc(docRef, { keyFrames: updatedKeyFrames });
            } catch(err) {
                appendLog(`수동 보정 저장 실패: ${err.message}`, 'text-red-500');
            }
        }

        async function handleDeleteAnalysis(analysisId) {
            const docData = allAnalysisData.find(d => d.id === analysisId);
            if (!docData) return;

            const confirmed = await showConfirmationModal('삭제 확인', `'${docData.fileName}' 기록을 정말 삭제하시겠습니까?`);
            if (!confirmed) return;
            
            try {
                if (currentLockedDocId === analysisId) {
                    currentLockedDocId = null;
                }
                const keyFrames = docData.keyFrames || [];
                const urlsToDelete = keyFrames.flatMap(kf => [kf.sharpFullUrl, kf.sharpCroppedUrl, kf.blurryFullUrl, kf.blurryCroppedUrl]).filter(Boolean);
                const deletePromises = urlsToDelete.map(url => deleteObject(ref(storage, url)));
                await Promise.all(deletePromises);

                await deleteDoc(doc(db, `public_data/shared_documents/analyses`, analysisId));
                
                if (detailChartCanvas.dataset.analysisId === analysisId) {
                    detailsSection.classList.add('hidden');
                }
            } catch(err) {
                appendLog(`기록 삭제 실패: ${err.message}`, 'text-red-500');
            }
        }

        // --- Main Analysis Logic ---
        videoFilesInput.addEventListener('change', (event) => { videoFiles = Array.from(event.target.files); updateAnalyzeButtonState(); });
        
        function updateThreshold(value, save = true) {
            const min = parseInt(thresholdSlider.min, 10);
            const max = parseInt(thresholdSlider.max, 10);
            let clampedValue = parseInt(value, 10);

            if (isNaN(clampedValue)) clampedValue = 50;

            clampedValue = Math.max(min, Math.min(max, clampedValue));

            thresholdSlider.value = clampedValue;
            thresholdValueEl.textContent = clampedValue;
            if (save) {
                localStorage.setItem('focusThreshold', clampedValue);
            }
        }

        thresholdSlider.addEventListener('input', (event) => updateThreshold(event.target.value));
        thresholdValueEl.addEventListener('blur', (event) => updateThreshold(event.target.textContent));
        thresholdValueEl.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                event.target.blur();
            }
        });
        
        cancelUploadBtn.addEventListener('click', () => {
            if (analysisController) {
                appendLog('사용자가 분석/업로드 중단을 요청했습니다.', 'text-yellow-500');
                analysisController.abort();
            }
        });

        async function uploadWithProgress(storageRef, blob, signal) {
            return new Promise((resolve, reject) => {
                if (!blob) return resolve(null); // Resolve with null if blob is null
                
                const uploadTask = uploadBytesResumable(storageRef, blob);

                const unsubscribe = uploadTask.on('state_changed', 
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        uploadProgressBar.style.width = `${progress}%`;
                    }, 
                    (error) => {
                        unsubscribe();
                        reject(error);
                    }, 
                    async () => {
                        unsubscribe();
                        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                        resolve(downloadURL);
                    }
                );
                
                signal.addEventListener('abort', () => {
                    unsubscribe();
                    uploadTask.cancel();
                });
            });
        }

        analyzeButton.addEventListener('click', async () => {
            loadingIndicator.style.display = 'flex';
            analyzeButton.disabled = true;
            cancelUploadBtn.classList.remove('hidden');
            thresholdSlider.disabled = true;
            thresholdValueEl.contentEditable = false;
            
            analysisController = new AbortController();
            const signal = analysisController.signal;

            const yieldToMain = () => new Promise(resolve => setTimeout(resolve, 0));

            try {
                const threshold = parseFloat(thresholdSlider.value);
                const analysisVideo = document.createElement('video');
                analysisVideo.crossOrigin = 'anonymous';
                const analysisCanvas = document.createElement('canvas');
                const analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });
                
                for (let i = 0; i < videoFiles.length; i++) {
                    if (signal.aborted) throw new Error("분석이 중단되었습니다.");
                    
                    const file = videoFiles[i];
                    
                    const fileURL = URL.createObjectURL(file);
                    analysisVideo.src = fileURL;

                    const duration = await new Promise(resolve => { 
                        analysisVideo.onloadedmetadata = () => resolve(analysisVideo.duration); 
                    });
                    
                    const frameScores = [];
                    let previousFrameState = { status: '미검출', fullFrameData: null, croppedFaceData: null, detectionBox: null, score: null };
                    const keyFramesData = [];
                    const SAMPLING_INTERVAL_SECONDS = 0.5;
                    const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);
                    
                    for (let j = 0; j < totalSamples; j++) {
                        if (signal.aborted) throw new Error("분석이 중단되었습니다.");
                        progressText.textContent = `프레임 분석 중... (${i + 1}/${videoFiles.length}) - ${j + 1}/${totalSamples}`;
                        
                        const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                        await new Promise(resolve => {
                            analysisVideo.onseeked = () => resolve(); 
                            analysisVideo.currentTime = currentTime;
                        });
                        
                        if (analysisCanvas.width !== analysisVideo.videoWidth) analysisCanvas.width = analysisVideo.videoWidth;
                        if (analysisCanvas.height !== analysisVideo.videoHeight) analysisCanvas.height = analysisVideo.videoHeight;
                        analysisCtx.drawImage(analysisVideo, 0, 0, analysisCanvas.width, analysisCanvas.height);
                        
                        const detections = await faceapi.detectAllFaces(analysisVideo, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 }));
                        const bestFace = getBestFace(detections, analysisVideo.videoWidth, analysisVideo.videoHeight);
                        
                        let currentStatus = '미검출';
                        let currentCroppedFace = null;
                        let currentDetectionBox = null;
                        let currentScore = null;

                        if (bestFace) {
                            const { x, y, width, height } = bestFace.box;
                            const faceImageData = analysisCtx.getImageData(x, y, width, height);
                            currentScore = calculateFocusScore(faceImageData);
                            currentStatus = currentScore < threshold ? '흐림' : '선명';
                            frameScores.push({ time: currentTime, score: currentScore });
                            currentCroppedFace = getCroppedFaceDataURL(analysisCanvas, bestFace.box);
                            currentDetectionBox = bestFace.box;
                        }

                        if (currentStatus === '흐림' && (previousFrameState.status === '선명' || previousFrameState.status === '미검출')) {
                             const blurryFullFrame = analysisCanvas.toDataURL('image/jpeg', 0.8);
                             const data = {
                                time: currentTime,
                                sharpFull: previousFrameState.fullFrameData,
                                sharpCropped: previousFrameState.croppedFaceData,
                                sharpBox: previousFrameState.detectionBox,
                                sharpScore: previousFrameState.score,
                                blurryFull: blurryFullFrame,
                                blurryCropped: currentCroppedFace,
                                blurryBox: currentDetectionBox,
                                blurryScore: currentScore
                            };
                            appendImageLog(data);
                            keyFramesData.push(data);
                        }
                        
                        previousFrameState = { 
                            status: currentStatus, 
                            fullFrameData: analysisCanvas.toDataURL('image/jpeg', 0.8),
                            croppedFaceData: currentCroppedFace,
                            detectionBox: currentDetectionBox,
                            score: currentScore
                        };
                        
                        await yieldToMain();
                    }
                    
                    let uploadedKeyFrames = [];
                    if (keyFramesData.length > 0) {
                        let selectedFrameIndices;

                        if (reviewBeforeUploadCheckbox.checked) {
                            progressText.textContent = `분석 완료. ${keyFramesData.length}개의 문제 의심 프레임을 검토하세요.`;
                            selectedFrameIndices = await showReviewModal(keyFramesData);
                        } else {
                            appendLog('자동 검토 모드로 모든 문제 프레임을 업로드합니다.', 'text-blue-400');
                            selectedFrameIndices = keyFramesData.map((_, index) => index); // Select all frames
                        }

                        if (selectedFrameIndices === null) {
                            throw new Error("사용자가 검토를 취소했습니다.");
                        }

                        if (selectedFrameIndices.length > 0) {
                            const framesToUpload = selectedFrameIndices.map(index => keyFramesData[index]);
                            uploadProgressContainer.classList.remove('hidden');
                            
                            for (let k = 0; k < framesToUpload.length; k++) {
                                if (signal.aborted) throw new Error("업로드가 중단되었습니다.");
                                
                                const kf = framesToUpload[k];
                                const timestamp = `${Date.now()}_${k}`;
                                
                                const blobs = {
                                    sharpFull: dataURLtoBlob(kf.sharpFull),
                                    sharpCropped: dataURLtoBlob(kf.sharpCropped),
                                    blurryFull: dataURLtoBlob(kf.blurryFull),
                                    blurryCropped: dataURLtoBlob(kf.blurryCropped)
                                };

                                const refs = {
                                    sharpFull: ref(storage, `public_assets/${timestamp}_sharp_full.jpeg`),
                                    sharpCropped: ref(storage, `public_assets/${timestamp}_sharp_crop.jpeg`),
                                    blurryFull: ref(storage, `public_assets/${timestamp}_blurry_full.jpeg`),
                                    blurryCropped: ref(storage, `public_assets/${timestamp}_blurry_crop.jpeg`)
                                };

                                const progressBase = k * 4;
                                const totalUploads = framesToUpload.length * 4;

                                progressText.textContent = `에셋 업로드 중... (${progressBase + 1}/${totalUploads})`;
                                const sharpFullUrl = await uploadWithProgress(refs.sharpFull, blobs.sharpFull, signal);
                                progressText.textContent = `에셋 업로드 중... (${progressBase + 2}/${totalUploads})`;
                                const sharpCroppedUrl = await uploadWithProgress(refs.sharpCropped, blobs.sharpCropped, signal);
                                progressText.textContent = `에셋 업로드 중... (${progressBase + 3}/${totalUploads})`;
                                const blurryFullUrl = await uploadWithProgress(refs.blurryFull, blobs.blurryFull, signal);
                                progressText.textContent = `에셋 업로드 중... (${progressBase + 4}/${totalUploads})`;
                                const blurryCroppedUrl = await uploadWithProgress(refs.blurryCropped, blobs.blurryCropped, signal);
                                
                                uploadedKeyFrames.push({ 
                                    time: kf.time, 
                                    sharpFullUrl, sharpCroppedUrl, blurryFullUrl, blurryCroppedUrl, 
                                    sharpBox: kf.sharpBox ? {x: kf.sharpBox.x, y: kf.sharpBox.y, width: kf.sharpBox.width, height: kf.sharpBox.height} : null,
                                    blurryBox: kf.blurryBox ? {x: kf.blurryBox.x, y: kf.blurryBox.y, width: kf.blurryBox.width, height: kf.blurryBox.height} : null,
                                    sharpScore: kf.sharpScore, blurryScore: kf.blurryScore
                                });
                            }
                        } else {
                             appendLog('업로드할 프레임이 선택되지 않았습니다.', 'text-yellow-500');
                        }
                    }

                    const totalScore = frameScores.reduce((sum, frame) => sum + frame.score, 0);
                    const avgScore = frameScores.length > 0 ? totalScore / frameScores.length : 0;
                    
                    const newAnalysis = {
                        fileName: file.name, timestamp: serverTimestamp(), avgScore,
                        problematic: uploadedKeyFrames.length > 0, frameScores, keyFrames: uploadedKeyFrames,
                        lock: null // Initialize lock field
                    };

                    await addDoc(collection(db, `public_data/shared_documents/analyses`), newAnalysis);
                    appendLog(`'${file.name}' 분석 완료 및 결과 저장.`, 'text-green-500');
                    URL.revokeObjectURL(fileURL);
                }
            } catch (error) {
                if (error.code === 'storage/canceled' || (error.message && (error.message.includes('canceled') || error.message.includes('중단')))) {
                    appendLog(`분석/업로드 중단됨: ${error.message}`, 'text-yellow-500');
                } else {
                    appendLog(`분석 중 오류 발생: ${error.message}`, 'text-red-500');
                    console.error("Analysis Error Stack:", error.stack);
                }
            } finally {
                loadingIndicator.style.display = 'none';
                cancelUploadBtn.classList.add('hidden');
                uploadProgressContainer.classList.add('hidden');
                uploadProgressBar.style.width = '0%';
                analyzeButton.disabled = false;
                thresholdSlider.disabled = false;
                thresholdValueEl.contentEditable = true;
                analysisController = null;
                videoFiles = [];
                videoFilesInput.value = '';
                updateAnalyzeButtonState();
            }
        });

        // Upload Test Modal Logic
        showUploadTestBtn.addEventListener('click', () => {
            uploadTestModalOverlay.classList.remove('hidden');
        });
        closeTestModalBtn.addEventListener('click', () => {
            uploadTestModalOverlay.classList.add('hidden');
        });
        uploadTestModalOverlay.addEventListener('click', (e) => {
            if (e.target === uploadTestModalOverlay) {
                uploadTestModalOverlay.classList.add('hidden');
            }
        });

        startStorageTestBtn.addEventListener('click', async () => {
            const file = testFileInput.files[0];
            const user = auth.currentUser;
            let heartbeatInterval;
            
            appendLog('[CLIENT] Storage 테스트 시작...', 'text-purple-400');
            
            if (!file) {
                appendLog('[CLIENT] 파일이 선택되지 않았습니다.', 'text-red-400');
                return;
            }
            appendLog(`[CLIENT] 선택된 파일: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`, 'text-purple-400');

            if (!user) {
                appendLog('[CLIENT] 인증 정보가 없습니다. 잠시 후 다시 시도하세요.', 'text-red-400');
                return;
            }
            appendLog(`[CLIENT] 현재 사용자 UID: ${user.uid}`, 'text-purple-400');

            const storagePath = `public_assets/test-uploads/${Date.now()}_${file.name}`;
            const storageRef = ref(storage, storagePath);
            appendLog(`[CLIENT] 업로드 경로 생성: ${storageRef.toString()}`, 'text-purple-400');
            
            appendLog('[CLIENT] uploadBytesResumable 함수 호출 시작...', 'text-purple-400');
            const uploadTask = uploadBytesResumable(storageRef, file);
            appendLog('[CLIENT] uploadBytesResumable 함수 호출 완료. UploadTask 객체 생성됨.', 'text-purple-400');

            let firstResponseReceived = false;
            let timeoutId = setTimeout(() => {
                if (!firstResponseReceived) {
                    uploadTask.cancel();
                    appendLog('[SERVER] 오류: 30초 응답 시간 초과. 서버로부터 어떠한 응답도 받지 못했습니다.', 'text-red-500');
                    clearInterval(heartbeatInterval);
                }
            }, 30000);

            heartbeatInterval = setInterval(() => {
                appendLog('[HEARTBEAT] UI 스레드 활성', 'text-gray-500');
            }, 500);

            appendLog('[CLIENT] state_changed 이벤트 리스너 설정 시작...', 'text-purple-400');
            uploadTask.on('state_changed',
                (snapshot) => {
                    if (!firstResponseReceived) {
                        firstResponseReceived = true;
                        clearTimeout(timeoutId);
                        appendLog('[SERVER] 첫 통신 성공. 업로드 등록 완료.', 'text-green-500', 'SERVER');
                    }
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    appendLog(`[SERVER] 진행률: ${Math.round(progress)}%`, 'text-green-500', 'SERVER');
                },
                (error) => {
                    clearTimeout(timeoutId);
                    clearInterval(heartbeatInterval);
                    appendLog(`[SERVER] Storage 업로드 실패: ${error.code}`, 'text-red-500', 'SERVER');
                    console.error("Test Upload Error:", error.stack);
                },
                async () => {
                    clearTimeout(timeoutId);
                    clearInterval(heartbeatInterval);
                    const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                    appendLog('[SERVER] Storage 업로드 성공!', 'text-green-500', 'SERVER');
                    appendLog(`[SERVER] URL: ${downloadURL}`, 'text-blue-400', 'SERVER');
                }
            );
            appendLog('[CLIENT] state_changed 이벤트 리스너 설정 완료. 서버 응답 대기 중...', 'text-purple-400');
        });

        startFirestoreTestBtn.addEventListener('click', async () => {
            appendLog('[CLIENT] Firestore 테스트 시작...', 'text-yellow-400');
            if (!auth.currentUser) {
                appendLog('[CLIENT] 인증 정보가 없습니다. 잠시 후 다시 시도하세요.', 'text-red-400');
                return;
            }
             appendLog(`[CLIENT] 현재 사용자 UID: ${auth.currentUser.uid}`, 'text-purple-400');

            const testDocPath = `public_data/shared_documents/test_writes`;
            appendLog(`[CLIENT] Firestore 쓰기 시도: ${testDocPath}`, 'text-purple-400');
            try {
                const docRef = await addDoc(collection(db, testDocPath), {
                    message: "Firestore write test successful!",
                    timestamp: serverTimestamp()
                });
                appendLog(`[SERVER] Firestore 쓰기 성공! (문서 ID: ${docRef.id})`, 'text-green-500', 'SERVER');
            } catch (error) {
                appendLog(`[SERVER] Firestore 쓰기 실패: ${error.code}`, 'text-red-500', 'SERVER');
                console.error("Test Firestore Write Error:", error.stack);
            }
        });


        window.onload = startApp;

    </script>
</body>
</html>
