<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 - v3.3 (모듈 임포트 오류 수정)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; scroll-behavior: smooth; padding-top: 60px; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-item:hover { background-color: #f0f9ff; cursor: pointer; }
        .result-item.selected { background-color: #dbeafe; border-left: 4px solid #2563eb; }
        .result-item.locked { background-color: #f1f5f9; opacity: 0.6; cursor: not-allowed; }
        .result-item.locked:hover { background-color: #f1f5f9; }
        #custom-modal-overlay, #upload-test-modal-overlay, #review-modal-overlay { background-color: rgba(0, 0, 0, 0.5); }
        .nav-link { transition: all 0.2s ease-in-out; }
        .nav-link:hover { color: #2563eb; transform: translateY(-2px); }
        .filter-select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
        .result-item.correction-completed { background-color: #f0fdf4; }
        .result-item.correction-completed .file-name { text-decoration: line-through; color: #6b7280; }
        .key-frame-item.highlighted { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- HTML Body -->
    <nav class="fixed top-0 left-0 right-0 bg-white/80 backdrop-blur-sm shadow-md z-40 h-[60px] flex items-center justify-center">
        <div class="container mx-auto px-4 flex justify-between items-center">
            <h1 class="text-xl md:text-2xl font-bold text-gray-900">
                포커스 이슈 탐지기
                <span id="version-display" class="text-sm align-middle text-blue-600 font-semibold"></span>
            </h1>
            <div class="hidden md:flex items-center space-x-6 font-semibold text-gray-600">
                <a href="#control-panel-section" class="nav-link">1. 제어판</a>
                <a href="#history-section" class="nav-link">2. 분석 기록</a>
                <a href="#details-section" class="nav-link">3. 상세 분석</a>
                <a href="#log-section" class="nav-link">4. 실시간 로그</a>
            </div>
            <div class="flex items-center">
                <button id="show-upload-test-btn" class="text-sm bg-gray-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-gray-600 transition">연결 테스트</button>
            </div>
        </div>
    </nav>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8 py-4">
            <p id="connection-status" class="text-sm text-gray-500 mt-1">연결 상태: 확인 중...</p>
            <p id="model-status" class="text-sm text-yellow-600 mt-1">인식 모델 로딩 중...</p>
        </header>
        
        <main class="space-y-8">
            <!-- Control Panel -->
            <div id="control-panel-section" class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 제어 패널</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                    <div class="space-y-6">
                        <div>
                            <label for="video-files-input" class="block text-sm font-medium text-gray-700 mb-1">영상 파일 선택</label>
                            <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                        </div>
                        <div class="space-y-2">
                            <label for="threshold-slider" class="block text-sm font-medium text-gray-700">흐림 기준값 (낮을수록 민감)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="threshold-value" contenteditable="true" class="font-bold text-lg text-blue-600 w-16 text-center cursor-text focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md px-1">50</span>
                            </div>
                        </div>
                    </div>
                    <!-- Category Inputs -->
                    <div class="space-y-4 p-4 bg-gray-50 rounded-lg border">
                        <h3 class="text-md font-semibold text-gray-800">분석 정보 입력</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                            <div>
                                <label for="year-input" class="block text-sm font-medium text-gray-700">연도</label>
                                <input type="number" id="year-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="event-type-input" class="block text-sm font-medium text-gray-700">이벤트 종류</label>
                                <input type="text" id="event-type-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="day-input" class="block text-sm font-medium text-gray-700">데이</label>
                                <input type="text" id="day-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                        </div>
                        <p class="text-xs text-gray-500">'테이블' 정보는 파일명(ONYX, DTD, LUXON)에 따라 자동으로 분류됩니다.</p>
                    </div>
                </div>
                <div class="mt-6">
                    <label for="review-before-upload-checkbox" class="flex items-center text-sm font-medium text-gray-700 cursor-pointer">
                        <input type="checkbox" id="review-before-upload-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                        <span class="ml-2">업로드 전 검토하기</span>
                    </label>
                </div>
                <div class="mt-6 text-center">
                    <button id="analyze-button" class="w-full md:w-auto bg-green-600 text-white font-bold py-3 px-12 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        분석 시작
                    </button>
                    <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center">
                        <div class="flex items-center justify-center space-x-4">
                            <div class="loader"></div>
                            <canvas id="preview-canvas" width="240" height="135" class="hidden bg-gray-200 rounded-md shadow-inner"></canvas>
                        </div>
                        <p id="progress-text" class="text-gray-600 mt-2"></p>
                        <div id="upload-progress-container" class="w-full mt-4 hidden">
                            <div class="w-full bg-gray-200 rounded-full h-4">
                                <div id="upload-progress-bar" class="bg-blue-600 h-4 rounded-full text-xs font-medium text-white text-center leading-4 transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <button id="cancel-upload-btn" class="hidden mt-4 bg-red-600 text-white font-bold py-2 px-6 rounded-full hover:bg-red-700 transition">
                            분석 중단
                        </button>
                    </div>
                </div>
            </div>

            <!-- Analysis History -->
            <div id="history-section" class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 기록</h2>
                <!-- Filter Controls -->
                <div id="filter-controls" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4 p-4 bg-gray-50 rounded-lg border">
                    <div>
                        <label for="year-filter" class="block text-sm font-medium text-gray-700">연도</label>
                        <select id="year-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="event-type-filter" class="block text-sm font-medium text-gray-700">이벤트 종류</label>
                        <select id="event-type-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="day-filter" class="block text-sm font-medium text-gray-700">데이</label>
                        <select id="day-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="table-filter" class="block text-sm font-medium text-gray-700">테이블</label>
                        <select id="table-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                </div>
                <div id="results-list-container" class="space-y-1 max-h-[60vh] overflow-y-auto">
                    <p id="results-list-placeholder" class="text-gray-500 text-center py-4">인증이 완료되면 기록을 불러옵니다...</p>
                </div>
                <div id="pagination-controls" class="pt-4 mt-4 border-t flex justify-center gap-2"></div>
            </div>

            <!-- Details Section -->
            <div id="details-section" class="hidden space-y-8">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 id="details-title" class="text-xl font-semibold mb-4 border-b pb-2 flex justify-between items-center">
                        <span>3. 상세 분석 그래프</span>
                        <button id="export-csv-btn" class="text-sm bg-blue-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-blue-600 transition">CSV로 내보내기</button>
                    </h2>
                    <p class="text-sm text-gray-600 mb-2 -mt-2">그래프 위 빨간 점에 마우스를 올리면 주요 프레임을 확인할 수 있습니다.</p>
                    <div id="chart-container" class="relative h-48 md:h-64">
                        <canvas id="detail-chart"></canvas>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 border-b pb-2">4. 주요 프레임 보기</h2>
                    <div id="key-frames-container" class="space-y-4">
                        <p id="key-frames-placeholder" class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없거나, 아직 기록이 선택되지 않았습니다.</p>
                    </div>
                </div>
            </div>
            
            <!-- Log Container -->
            <div id="log-section" class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">실시간 분석 로그</h2>
                <div id="log-container" class="min-h-[10rem] max-h-[50rem] overflow-y-auto bg-gray-900 text-white font-mono rounded-lg p-4 border text-sm"><p id="log-placeholder" class="text-gray-400 text-center py-4">분석을 시작하거나 과거 기록을 선택하면 로그가 표시됩니다.</p></div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="review-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-4xl transform transition-transform duration-300 scale-95 flex flex-col h-[90vh]">
            <div class="flex justify-between items-center mb-4 border-b pb-3">
                <h3 class="text-lg font-bold text-gray-900">업로드 전 검토</h3>
                <button id="close-review-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <p class="text-sm text-gray-600 mb-4">업로드할 문제 프레임을 선택하세요. 선택 해제된 항목은 서버에 저장되지 않습니다.</p>
            <div id="review-frames-list" class="flex-grow overflow-y-auto space-y-4 pr-2"></div>
            <div class="mt-6 flex justify-end space-x-3 border-t pt-4">
                <button id="review-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">전체 취소</button>
                <button id="review-confirm-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">선택한 프레임 업로드</button>
            </div>
        </div>
    </div>
    <div id="upload-test-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="upload-test-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-lg transform transition-transform duration-300 scale-95">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-900">Firebase 연결 테스트</h3>
                <button id="close-test-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <h4 class="font-semibold mb-2">1. Storage 업로드 테스트</h4>
                    <input type="file" id="test-file-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer mb-2"/>
                    <button id="start-storage-test-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700 transition">Storage 테스트 시작</button>
                </div>
                <div class="border-t my-4"></div>
                <div>
                    <h4 class="font-semibold mb-2">2. Firestore 쓰기 테스트</h4>
                    <button id="start-firestore-test-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-full hover:bg-indigo-700 transition">Firestore 테스트 시작</button>
                </div>
            </div>
        </div>
    </div>
    <div id="custom-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="custom-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-md transform transition-transform duration-300 scale-95">
            <h3 id="modal-title" class="text-lg font-bold text-gray-900">확인</h3>
            <p id="modal-message" class="mt-2 text-sm text-gray-600">이 작업을 정말로 수행하시겠습니까?</p>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">취소</button>
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">확인</button>
            </div>
        </div>
    </div>

    <!-- 
    ================================================================
    ANALYSIS WORKER SCRIPT
    ================================================================
    -->
    <script type="text/plain" id="analysis-worker-script">
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData;
            if (width === 0 || height === 0) return 0;
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            let laplacianMean = 0;
            const laplacianValues = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;
                    const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                    laplacianValues.push(laplacian);
                    laplacianMean += laplacian;
                }
            }
            if (laplacianValues.length === 0) return 0;
            laplacianMean /= laplacianValues.length;
            const variance = laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
            return variance;
        }

        function getBestFace(detections, videoWidth, videoHeight) {
             if (!detections || detections.length === 0) return null;
             if (detections.length === 1) return detections[0];
             const frameCenterX = videoWidth / 2;
             const frameCenterY = videoHeight / 2;
             const scoredDetections = detections.map(detection => {
                 const { box } = detection;
                 const area = box.width * box.height;
                 const faceCenterX = box.x + box.width / 2;
                 const faceCenterY = box.y + box.height / 2;
                 const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2));
                 return { detection, area, distance };
             });
             const maxArea = Math.max(...scoredDetections.map(d => d.area));
             const maxDistance = Math.max(...scoredDetections.map(d => d.distance));
             const safeMaxArea = maxArea === 0 ? 1 : maxArea;
             const safeMaxDistance = maxDistance === 0 ? 1 : maxDistance;
             let bestDetection = null;
             let maxScore = -1;
             for (const item of scoredDetections) {
                 const sizeScore = item.area / safeMaxArea;
                 const distanceScore = 1 - (item.distance / safeMaxDistance);
                 const finalScore = (sizeScore * 0.4) + (distanceScore * 0.6);
                 if (finalScore > maxScore) {
                     maxScore = finalScore;
                     bestDetection = item.detection;
                 }
             }
             return bestDetection;
        }

        async function getCroppedFaceDataURL(canvas, box) {
            if (!box) return null;
            const { x, y, width, height } = box;
            const tempCanvas = new OffscreenCanvas(width, height);
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
            return await tempCanvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
        }
        
        async function analyzeVideoFile(file, options) {
            const { threshold, detectionCanvasWidth, fileIndex, totalFiles } = options;
            
            const video = document.createElement('video');
            const canvas = new OffscreenCanvas(1, 1);
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const detectionCanvas = new OffscreenCanvas(1, 1);
            const detectionCtx = detectionCanvas.getContext('2d');
            
            video.src = URL.createObjectURL(file);
            const duration = await new Promise(resolve => {
                video.onloadedmetadata = () => resolve(video.duration);
            });

            const frameScores = [];
            let previousFrameState = { status: '미검출', fullFrameData: null, croppedFaceData: null, score: null };
            const keyFramesData = [];
            const SAMPLING_INTERVAL_SECONDS = 0.5;
            const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);

            for (let j = 0; j < totalSamples; j++) {
                const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                
                const progressPayload = { 
                    text: `파일 분석 중 (${fileIndex + 1}/${totalFiles}) - ${j + 1}/${totalSamples}`, 
                    time: currentTime, 
                    duration 
                };
                
                if (j % 2 === 0) {
                    const previewCanvas = new OffscreenCanvas(240, 135);
                    const previewCtx = previewCanvas.getContext('2d');
                    previewCtx.drawImage(video, 0, 0, 240, 135);
                    progressPayload.previewBitmap = previewCanvas.transferToImageBitmap();
                }
                self.postMessage({ type: 'progress', payload: progressPayload }, progressPayload.previewBitmap ? [progressPayload.previewBitmap] : []);

                await new Promise(resolve => {
                    video.onseeked = () => resolve();
                    video.currentTime = currentTime;
                });
                
                if (canvas.width !== video.videoWidth) canvas.width = video.videoWidth;
                if (canvas.height !== video.videoHeight) canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                const scale = detectionCanvasWidth / video.videoWidth;
                detectionCanvas.width = detectionCanvasWidth;
                detectionCanvas.height = video.videoHeight * scale;
                detectionCtx.drawImage(video, 0, 0, detectionCanvas.width, detectionCanvas.height);
                
                const detections = await faceapi.detectAllFaces(detectionCanvas, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 }));
                const resizedDetections = faceapi.resizeResults(detections, { width: canvas.width, height: canvas.height });
                const bestFace = getBestFace(resizedDetections, canvas.width, canvas.height);

                let currentStatus = '미검출', currentCroppedFace = null, currentScore = null;

                if (bestFace) {
                    const { x, y, width, height } = bestFace.box;
                    const faceImageData = ctx.getImageData(x, y, width, height);
                    currentScore = calculateFocusScore(faceImageData);
                    currentStatus = currentScore < threshold ? '흐림' : '선명';
                    frameScores.push({ time: currentTime, score: currentScore });
                    currentCroppedFace = await getCroppedFaceDataURL(canvas, bestFace.box);
                }

                if (currentStatus === '흐림' && (previousFrameState.status === '선명' || previousFrameState.status === '미검출')) {
                    const blurryFullFrame = await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
                    const data = {
                        time: currentTime,
                        sharpFull: previousFrameState.fullFrameData,
                        sharpCropped: previousFrameState.croppedFaceData,
                        sharpScore: previousFrameState.score,
                        blurryFull: blurryFullFrame,
                        blurryCropped: currentCroppedFace,
                        blurryScore: currentScore
                    };
                    keyFramesData.push(data);
                    self.postMessage({ type: 'log', payload: { message: `문제 의심 프레임 감지 @ ${currentTime.toFixed(2)}초`, color: 'text-yellow-400' }});
                }

                previousFrameState = {
                    status: currentStatus,
                    fullFrameData: await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 }),
                    croppedFaceData: currentCroppedFace,
                    score: currentScore
                };
            }
            
            URL.revokeObjectURL(video.src);
            return { fileName: file.name, frameScores, keyFramesData };
        }

        self.onmessage = async (event) => {
            const { file, options } = event.data;
            try {
                if (!self.faceapi) {
                    self.importScripts(options.faceApiUrl);
                }
                if (!faceapi.nets.ssdMobilenetv1.isLoaded) {
                     await faceapi.nets.ssdMobilenetv1.loadFromUri(options.modelUrl);
                }
                const result = await analyzeVideoFile(file, options);
                self.postMessage({ type: 'result', payload: result });
            } catch (error) {
                self.postMessage({ type: 'error', payload: { message: error.message, stack: error.stack } });
            }
        };
    </script>
    
    <!-- 
    ================================================================
    MAIN APPLICATION SCRIPT
    ================================================================
    -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        const C = {
            APP_VERSION: "3.2",
            FIREBASE_COLLECTION: 'public_data/shared_documents/analyses',
            STORAGE_PATH: 'public_assets',
            TEST_STORAGE_PATH: 'public_assets/test-uploads',
            TEST_FIRESTORE_PATH: 'public_data/shared_documents/test_writes',
            LOCAL_STORAGE_KEY: 'focusThreshold',
            DEFAULT_THRESHOLD: 50,
            LOCK_TIMEOUT_MS: 5 * 60 * 1000,
            ITEMS_PER_PAGE: 20,
            MODEL_URL: 'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js',
            MODEL_WEIGHTS_URL: 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights',
            DETECTION_CANVAS_WIDTH: 480,
            FILTER_ALL: 'all',
            MANUAL_OVERRIDE: { OK: 'ok' },
        };

        const AppState = {
            modelsLoaded: false,
            firebaseReady: false,
            isAnalyzing: false,
            allAnalyses: [],
            filteredAnalyses: [],
            currentPage: 1,
            analysisWorker: null,
            currentLockedDocId: null,
            lockHeartbeat: null,
            lastAddedDocId: null,
            detailChart: null,
            reviewModalResolve: null,
            reviewModalObjectUrls: [],
            modalResolve: null,
            filters: { year: C.FILTER_ALL, eventType: C.FILTER_ALL, day: C.FILTER_ALL, table: C.FILTER_ALL }
        };

        const D = {};
        function initDom() {
            const ids = [
                'version-display', 'connection-status', 'model-status', 'video-files-input',
                'threshold-slider', 'threshold-value', 'review-before-upload-checkbox',
                'analyze-button', 'loading-indicator', 'progress-text', 'upload-progress-container',
                'upload-progress-bar', 'cancel-upload-btn', 'results-list-container',
                'results-list-placeholder', 'pagination-controls', 'details-section',
                'details-title', 'detail-chart', 'log-container', 'key-frames-container',
                'export-csv-btn', 'show-upload-test-btn', 'upload-test-modal-overlay',
                'close-test-modal-btn', 'test-file-input', 'start-storage-test-btn',
                'start-firestore-test-btn', 'review-modal-overlay', 'review-frames-list',
                'close-review-modal-btn', 'review-cancel-btn', 'review-confirm-btn',
                'preview-canvas', 'year-filter', 'event-type-filter', 'day-filter',
                'table-filter', 'year-input', 'event-type-input', 'day-input', 'log-placeholder',
                'key-frames-placeholder', 'custom-modal-overlay', 'custom-modal', 'modal-title',
                'modal-message', 'modal-cancel-btn', 'modal-confirm-btn'
            ];
            ids.forEach(id => {
                const key = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                D[key] = document.getElementById(id);
            });
            D.previewCtx = D.previewCanvas.getContext('2d');
        }

        const Firebase = {
            app: null, auth: null, db: null, storage: null,
            init(onAuthReady) {
                const firebaseConfig = {
                    apiKey: "AIzaSyAyTh3kG9pPcgqcs-MHXSBKFgY_gnRWae0",
                    authDomain: "analyze-frame-focus.firebaseapp.com",
                    projectId: "analyze-frame-focus",
                    storageBucket: "analyze-frame-focus.appspot.com",
                    messagingSenderId: "995861796391",
                    appId: "1:995861796391:web:549944764ca046594c2002"
                };
                 try {
                    this.app = initializeApp(firebaseConfig);
                    this.auth = getAuth(this.app);
                    this.db = getFirestore(this.app);
                    this.storage = getStorage(this.app);
                    onAuthStateChanged(this.auth, async (user) => {
                        if (user) onAuthReady(user);
                        else await signInAnonymously(this.auth);
                    });
                     AppState.firebaseReady = true;
                     return { success: true, projectId: firebaseConfig.projectId };
                } catch (e) {
                     AppState.firebaseReady = false;
                     return { success: false, error: e };
                }
            }
        };
        
        const api = {
            listenForAnalyses(callback) {
                 const q = collection(Firebase.db, C.FIREBASE_COLLECTION);
                 return onSnapshot(q, (snapshot) => {
                     const analyses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                     analyses.sort((a, b) => (b.timestamp?.seconds ?? 0) - (a.timestamp?.seconds ?? 0));
                     callback(analyses);
                 }, (error) => ui.appendLog(`DB 데이터 수신 오류: ${error.message}`, 'text-red-500'));
            },
            async addAnalysis(analysisData) {
                const docRef = await addDoc(collection(Firebase.db, C.FIREBASE_COLLECTION), { ...analysisData, timestamp: serverTimestamp(), lock: null });
                return docRef.id;
            },
            async uploadFile(path, blob, onProgress) {
                if (!blob) return null;
                const storageRef = ref(Firebase.storage, path);
                const uploadTask = uploadBytesResumable(storageRef, blob);
                return new Promise((resolve, reject) => {
                    uploadTask.on('state_changed',
                        (s) => onProgress && onProgress((s.bytesTransferred / s.totalBytes)),
                        (e) => reject(e),
                        async () => resolve(await getDownloadURL(uploadTask.snapshot.ref))
                    );
                });
            },
            async releaseLock(docId) {
                if (!docId) return;
                clearInterval(AppState.lockHeartbeat);
                AppState.lockHeartbeat = null;
                const docRef = doc(Firebase.db, C.FIREBASE_COLLECTION, docId);
                try { await updateDoc(docRef, { lock: null }); } 
                catch (error) { console.error(`Failed to release lock for ${docId}:`, error); }
            },
            async acquireLock(docId) {
                if (!docId || !Firebase.auth.currentUser) return false;
                const docRef = doc(Firebase.db, C.FIREBASE_COLLECTION, docId);
                try {
                    await runTransaction(Firebase.db, async (transaction) => {
                        const sfDoc = await transaction.get(docRef);
                        if (!sfDoc.exists()) throw new Error("문서가 존재하지 않습니다.");
                        const data = sfDoc.data();
                        const lock = data.lock;
                        const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > C.LOCK_TIMEOUT_MS;
                        if (lock && !isStale && lock.lockedBy !== Firebase.auth.currentUser.uid) throw new Error("다른 사용자가 이 항목을 사용 중입니다.");
                        const newLock = { lockedBy: Firebase.auth.currentUser.uid, lockedAt: serverTimestamp() };
                        transaction.update(docRef, { lock: newLock });
                    });
                    AppState.lockHeartbeat = setInterval(() => api.updateLock(docId), 60 * 1000);
                    return true;
                } catch (error) {
                    ui.appendLog(`항목을 잠글 수 없습니다: ${error.message}`, 'text-red-500');
                    return false;
                }
            },
            async updateLock(docId) {
                await updateDoc(doc(Firebase.db, C.FIREBASE_COLLECTION, docId), { "lock.lockedAt": serverTimestamp() });
            },
            async updateAnalysis(docId, data) {
                 await updateDoc(doc(Firebase.db, C.FIREBASE_COLLECTION, docId), data);
            },
            async deleteAnalysis(analysis) {
                 const urlsToDelete = (analysis.keyFrames || []).flatMap(kf => [kf.sharpFullUrl, kf.sharpCroppedUrl, kf.blurryFullUrl, kf.blurryCroppedUrl]).filter(Boolean);
                 const deletePromises = urlsToDelete.map(url => deleteObject(ref(Firebase.storage, url)).catch(e => console.warn(`Failed to delete ${url}`, e)));
                 await Promise.all(deletePromises);
                 await deleteDoc(doc(Firebase.db, C.FIREBASE_COLLECTION, analysis.id));
            }
        };

        const ui = {
            appendLog(message, colorClass = 'text-gray-400', source = 'APP') {
                if (D.logPlaceholder) { D.logPlaceholder.remove(); D.logPlaceholder = null; }
                const logEntry = document.createElement('div');
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] [${source}] ${message}`;
                logEntry.className = colorClass;
                D.logContainer.appendChild(logEntry);
                D.logContainer.scrollTop = D.logContainer.scrollHeight;
            },
            setLoadingState(isLoading) {
                 AppState.isAnalyzing = isLoading;
                 D.loadingIndicator.style.display = isLoading ? 'flex' : 'none';
                 D.previewCanvas.classList.toggle('hidden', !isLoading);
                 D.analyzeButton.disabled = isLoading;
                 D.cancelUploadBtn.classList.toggle('hidden', !isLoading);
                 D.thresholdSlider.disabled = isLoading;
                 if (!isLoading) {
                    D.uploadProgressContainer.classList.add('hidden');
                    D.uploadProgressBar.style.width = '0%';
                    D.videoFilesInput.value = '';
                    this.updateAnalyzeButtonState();
                 }
            },
            updateAnalyzeButtonState() {
                const files = D.videoFilesInput.files;
                D.analyzeButton.disabled = (files && files.length === 0) || !AppState.modelsLoaded || AppState.isAnalyzing;
            },
            updateAnalysisProgress(payload) {
                D.progressText.textContent = payload.text;
                if (payload.previewBitmap) {
                    D.previewCtx.clearRect(0, 0, D.previewCanvas.width, D.previewCanvas.height);
                    D.previewCtx.drawImage(payload.previewBitmap, 0, 0);
                }
            },
            updateUploadProgress(progress) {
                 D.uploadProgressContainer.classList.remove('hidden');
                 const percent = Math.round(progress * 100);
                 D.uploadProgressBar.style.width = `${percent}%`;
                 D.uploadProgressBar.textContent = `${percent}%`;
                 D.progressText.textContent = `키프레임 에셋 업로드 중...`;
            },
            renderResultsList() {
                D.resultsListPlaceholder.classList.add('hidden');
                D.resultsListContainer.innerHTML = '';
                
                const filteredData = AppState.filteredAnalyses;

                if (filteredData.length === 0) {
                    D.resultsListPlaceholder.textContent = '선택한 필터에 해당하는 기록이 없습니다.';
                    D.resultsListPlaceholder.classList.remove('hidden');
                    D.paginationControls.innerHTML = '';
                    return;
                }

                const totalPages = Math.ceil(filteredData.length / C.ITEMS_PER_PAGE);
                AppState.currentPage = Math.min(AppState.currentPage, totalPages || 1);
                const startIndex = (AppState.currentPage - 1) * C.ITEMS_PER_PAGE;
                const paginatedData = filteredData.slice(startIndex, startIndex + C.ITEMS_PER_PAGE);

                paginatedData.forEach(data => this.createResultItemElement(data));
                this.renderPagination(totalPages, filteredData.length);
            },
            createResultItemElement(data) {
                const item = document.createElement('div');
                const dateString = data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString() : '날짜 없음';
                const problemCount = (data.keyFrames || []).filter(kf => kf.manualOverride !== C.MANUAL_OVERRIDE.OK).length;
                
                const lock = data.lock;
                const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > C.LOCK_TIMEOUT_MS;
                const isLocked = lock && !isStale;
                const isLockedByCurrentUser = isLocked && Firebase.auth.currentUser && lock.lockedBy === Firebase.auth.currentUser.uid;
                const isLockedByOther = isLocked && !isLockedByCurrentUser;

                item.className = `result-item p-3 border-b flex justify-between items-center transition-colors duration-200`;
                if (isLockedByOther) item.classList.add('locked');
                if (isLockedByCurrentUser || data.id === AppState.currentLockedDocId) item.classList.add('selected');
                if (data.correctionCompleted) item.classList.add('correction-completed');

                item.dataset.analysisId = data.id;

                let lockIcon = '';
                if (isLockedByOther) lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-gray-500 mr-2 shrink-0" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg>`;
                else if (isLockedByCurrentUser) lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-blue-600 mr-2 shrink-0" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8m1.173-1.173a14.3 14.3 0 0 1 1.66-2.043C4.12 3.4 5.88 2.5 8 2.5s3.879.9 5.168 2.287a14.3 14.3 0 0 1 1.66 2.043A14.3 14.3 0 0 1 16 8s-.9 1.88-2.287 3.173a14.3 14.3 0 0 1-1.66 2.043C11.879 14.6 10.12 15.5 8 15.5s-3.879-.9-5.168-2.287a14.3 14.3 0 0 1-1.66-2.043A14.3 14.3 0 0 1 0 8s.9-1.88 2.287-3.173Z"/></svg>`;

                item.innerHTML = `
                    <div class="flex-grow overflow-hidden flex items-center">
                        <input type="checkbox" class="correction-checkbox h-5 w-5 mr-4 text-green-600 border-gray-300 rounded focus:ring-green-500 cursor-pointer shrink-0" ${data.correctionCompleted ? 'checked' : ''}>
                        ${lockIcon}
                        <div>
                            <p class="font-medium file-name text-gray-800 truncate text-sm" title="${data.fileName}">${data.fileName}</p>
                            <p class="text-xs text-gray-500">${dateString}</p>
                        </div>
                    </div>
                    <div class="flex items-center ml-2 shrink-0">
                        <span class="inline-block bg-gray-200 text-gray-800 text-xs font-semibold mr-4 px-2.5 py-0.5 rounded-full">${data.table || 'N/A'}</span>
                        <div class="text-sm font-semibold ${problemCount > 0 ? 'text-red-500' : 'text-green-600'} w-28 text-right">문제 프레임: ${problemCount}개</div>
                        <button class="delete-analysis-button ml-4 text-gray-400 hover:text-red-600 p-2 rounded-full hover:bg-red-100 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" class="pointer-events-none">
                                <path d="M11 1.5v1h3.5a.5.5 0 0 1 0 1h-.538l-.853 10.66A2 2 0 0 1 11.115 16h-6.23a2 2 0 0 1-1.994-1.84L2.038 3.5H1.5a.5.5 0 0 1 0-1H5v-1A1.5 1.5 0 0 1 6.5 0h3A1.5 1.5 0 0 1 11 1.5m-5 0v1h4v-1a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5M4.5 5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5-.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06"/>
                            </svg>
                        </button>
                    </div>`;
                D.resultsListContainer.appendChild(item);
            },
            renderPagination(totalPages, totalItems) {
                D.paginationControls.innerHTML = '';
                if (totalItems <= C.ITEMS_PER_PAGE) return;
                for (let i = 1; i <= totalPages; i++) {
                    const button = document.createElement('button');
                    button.textContent = i;
                    button.className = `px-3 py-1 rounded-md text-sm transition-colors ${i === AppState.currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`;
                    button.onclick = () => { AppState.currentPage = i; this.renderResultsList(); };
                    D.paginationControls.appendChild(button);
                }
            },
            renderDetailedView(analysis) {
                if (!analysis) {
                    D.detailsSection.classList.add('hidden');
                    return;
                }
                D.detailsSection.classList.remove('hidden');
                D.detailsTitle.querySelector('span').textContent = `3. 상세 분석: ${analysis.fileName}`;
                this.renderDetailChart(analysis);
                this.renderKeyFramesForDetail(analysis);
                D.detailsSection.scrollIntoView({ behavior: 'smooth' });
            },
            renderDetailChart(analysisData) {
                if (AppState.detailChart) AppState.detailChart.destroy();
                
                const frameScores = analysisData.frameScores || [];
                const keyFrames = analysisData.keyFrames || [];

                const blurryPoints = keyFrames.filter(kf => kf.manualOverride !== C.MANUAL_OVERRIDE.OK).map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));
                const okPoints = keyFrames.filter(kf => kf.manualOverride === C.MANUAL_OVERRIDE.OK).map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));

                AppState.detailChart = new Chart(D.detailChart, {
                    type: 'line',
                    data: {
                        datasets: [
                            { label: '선명도', data: frameScores.map(fs => ({x: fs.time, y: fs.score})), borderColor: 'rgba(59, 130, 246, 0.5)', borderWidth: 1.5, pointRadius: 0, tension: 0.4 },
                            { label: '흐림 감지', data: blurryPoints, backgroundColor: 'rgb(239, 68, 68)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' },
                            { label: '수동 확인 (OK)', data: okPoints, backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { title: { display: true, text: '선명도 점수' } } },
                        plugins: { legend: { position: 'top' }, tooltip: { enabled: true } },
                        onHover: (event, chartElement) => {
                            D.detailChart.style.cursor = 'default';
                            document.querySelectorAll('.key-frame-item.highlighted').forEach(el => el.classList.remove('highlighted'));

                            if (chartElement.length > 0) {
                                const element = chartElement[0];
                                if (element.datasetIndex === 1 || element.datasetIndex === 2) {
                                    D.detailChart.style.cursor = 'pointer';
                                    const timeValue = AppState.detailChart.data.datasets[element.datasetIndex].data[element.index].x;
                                    const targetFrame = D.keyFramesContainer.querySelector(`.key-frame-item[data-time="${timeValue}"]`);
                                    if (targetFrame) {
                                        targetFrame.classList.add('highlighted');
                                        targetFrame.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }
                                }
                            }
                        },
                    }
                });
            },
            renderKeyFramesForDetail(analysisData) {
                D.keyFramesContainer.innerHTML = '';
                const keyFrames = analysisData.keyFrames || [];
                if (keyFrames.length === 0) {
                    D.keyFramesContainer.innerHTML = `<p id="key-frames-placeholder" class="text-gray-500 text-center py-4">감지된 문제 프레임이 없습니다.</p>`;
                    return;
                }

                keyFrames.sort((a, b) => a.time - b.time).forEach(data => {
                    const isOverridden = data.manualOverride === C.MANUAL_OVERRIDE.OK;
                    const item = document.createElement('div');
                    item.className = 'key-frame-item p-4 bg-gray-50 rounded-lg shadow-inner border space-y-4 transition-all duration-300';
                    item.dataset.time = data.time;

                    item.innerHTML = `
                        <h4 class="font-bold text-md">@ ${data.time.toFixed(2)}초</h4>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <p class="text-xs font-semibold text-green-600 mb-1">이전 프레임 (전체) - 점수: ${data.sharpScore?.toFixed(2) ?? 'N/A'}</p>
                                <img src="${data.sharpFullUrl}" class="w-full rounded-md border" loading="lazy" onerror="this.src='https://placehold.co/400x225/e2e8f0/475569?text=Image+Error'">
                                <p class="text-xs font-semibold text-green-600 mt-2 mb-1">이전 프레임 (얼굴)</p>
                                <img src="${data.sharpCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy" onerror="this.src='https://placehold.co/300x200/e2e8f0/475569?text=Image+Error'">
                            </div>
                            <div>
                                <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mb-1">문제 프레임 (전체) - 점수: ${data.blurryScore?.toFixed(2) ?? 'N/A'}</p>
                                <img src="${data.blurryFullUrl}" class="w-full rounded-md border" loading="lazy" onerror="this.src='https://placehold.co/400x225/e2e8f0/475569?text=Image+Error'">
                                <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mt-2 mb-1">문제 프레임 (얼굴)</p>
                                <img src="${data.blurryCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy" onerror="this.src='https://placehold.co/300x200/e2e8f0/475569?text=Image+Error'">
                            </div>
                        </div>
                        <button data-action="ok" class="manual-override-button w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm ${isOverridden ? 'hidden' : ''}">이 프레임은 문제 없음</button>
                        <button data-action="problem" class="manual-override-button w-full px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 text-sm ${!isOverridden ? 'hidden' : ''}">문제 프레임으로 되돌리기</button>
                    `;
                    D.keyFramesContainer.appendChild(item);
                });
            }
        };

        // ================================================================
        // VIRTUAL MODULE: main.js (Application Orchestrator)
        // ================================================================
        
        function initialize() {
            initDom();
            D.versionDisplay.textContent = `v${C.APP_VERSION}`;
            document.title = `포커스 이슈 탐지기 - v${C.APP_VERSION}`;
            setupEventListeners();
            
            const fbInit = Firebase.init(handleAuthReady);
            if (fbInit.success) {
                D.connectionStatus.textContent = `연결 상태: 연결 성공 (${fbInit.projectId})`;
                D.connectionStatus.className = 'text-sm text-green-600 mt-1';
                ui.appendLog(`Firebase 연결 성공 (Project: ${fbInit.projectId})`, 'text-green-500');
            } else {
                 D.connectionStatus.textContent = `오류: Firebase 초기화 실패: ${fbInit.error.message}`;
                 D.connectionStatus.className = 'text-sm text-red-600 mt-1';
                 ui.appendLog(`Firebase 초기화 오류: ${fbInit.error.message}`, 'text-red-500');
            }
            loadModels();
        }

        function handleAuthReady(user) {
            ui.appendLog(`인증 완료 (UID: ${user.uid})`, 'text-green-500');
            api.listenForAnalyses((analyses) => {
                AppState.allAnalyses = analyses;
                filterAndRenderResults();
                const currentAnalysis = AppState.allAnalyses.find(a => a.id === AppState.currentLockedDocId);
                if (currentAnalysis) {
                    ui.renderDetailedView(currentAnalysis);
                }
                ui.appendLog(`데이터베이스로부터 ${analyses.length}개 기록 수신.`, 'text-blue-400');
            });
        }
        
        async function loadModels() {
            try {
                await faceapi.nets.ssdMobilenetv1.loadFromUri(C.MODEL_WEIGHTS_URL);
                AppState.modelsLoaded = true;
                D.modelStatus.textContent = '얼굴 인식 모델 로딩 완료!';
                D.modelStatus.className = 'text-sm text-green-600 mt-1';
                ui.updateAnalyzeButtonState();
            } catch (error) {
                D.modelStatus.textContent = '모델 로딩 실패';
                ui.appendLog(`모델 로딩 실패: ${error.message}`, 'text-red-500');
            }
        }
        
        function setupEventListeners() {
             D.videoFilesInput.addEventListener('change', () => ui.updateAnalyzeButtonState());
             D.analyzeButton.addEventListener('click', startAnalysis);
             D.cancelUploadBtn.addEventListener('click', cancelAnalysis);
             D.resultsListContainer.addEventListener('click', handleResultListClick);
             D.keyFramesContainer.addEventListener('click', handleKeyFrameClick);
             [D.yearFilter, D.eventTypeFilter, D.dayFilter, D.tableFilter].forEach(filter => {
                filter.addEventListener('change', handleFilterChange);
             });
             // Test Modal Listeners
             D.showUploadTestBtn.addEventListener('click', () => D.uploadTestModalOverlay.classList.remove('hidden'));
             D.closeTestModalBtn.addEventListener('click', () => D.uploadTestModalOverlay.classList.add('hidden'));
             D.uploadTestModalOverlay.addEventListener('click', (e) => {
                if (e.target === D.uploadTestModalOverlay) D.uploadTestModalOverlay.classList.add('hidden');
             });
             D.startStorageTestBtn.addEventListener('click', handleStorageTest);
             D.startFirestoreTestBtn.addEventListener('click', handleFirestoreTest);
        }
        
        function filterAndRenderResults() {
             AppState.filteredAnalyses = AppState.allAnalyses.filter(item => {
                const { year, eventType, day, table } = AppState.filters;
                const yearMatch = year === C.FILTER_ALL || String(item.year) === year;
                const eventTypeMatch = eventType === C.FILTER_ALL || item.eventType === eventType;
                const dayMatch = day === C.FILTER_ALL || item.day === day;
                const tableMatch = table === C.FILTER_ALL || item.table === table;
                return yearMatch && eventTypeMatch && dayMatch && tableMatch;
            });
            ui.renderResultsList();
        }

        function handleFilterChange(e) {
            const filterId = e.target.id;
            const key = filterId.replace('-filter', '');
            AppState.filters[key] = e.target.value;
            AppState.currentPage = 1;
            filterAndRenderResults();
        }

        async function handleResultListClick(e) {
            const resultItem = e.target.closest('.result-item');
            if (!resultItem) return;
            const analysisId = resultItem.dataset.analysisId;
            const analysis = AppState.allAnalyses.find(a => a.id === analysisId);
            
            if (e.target.classList.contains('correction-checkbox')) {
                await api.updateAnalysis(analysisId, { correctionCompleted: e.target.checked });
                return;
            }
            if (e.target.closest('.delete-analysis-button')) {
                // await handleDeleteAnalysis(analysis);
                return;
            }
            if (resultItem.classList.contains('locked')) return;
            if (analysisId === AppState.currentLockedDocId) return;

            await api.releaseLock(AppState.currentLockedDocId);
            const lockAcquired = await api.acquireLock(analysisId);
            if (lockAcquired) {
                AppState.currentLockedDocId = analysisId;
                ui.renderDetailedView(analysis);
                filterAndRenderResults();
            }
        }

        async function handleKeyFrameClick(e) {
            const button = e.target.closest('.manual-override-button');
            if (!button) return;
            const keyFrameItem = button.closest('.key-frame-item');
            const time = parseFloat(keyFrameItem.dataset.time);
            const action = button.dataset.action;
            const analysisId = AppState.currentLockedDocId;
            
            const analysis = AppState.allAnalyses.find(a => a.id === analysisId);
            if (!analysis) return;

            const updatedKeyFrames = analysis.keyFrames.map(kf => {
                if (kf.time === time) {
                    if (action === 'ok') return { ...kf, manualOverride: C.MANUAL_OVERRIDE.OK };
                    const { manualOverride, ...rest } = kf;
                    return rest;
                }
                return kf;
            });
            await api.updateAnalysis(analysisId, { keyFrames: updatedKeyFrames });
        }

        function startAnalysis() {
            const files = Array.from(D.videoFilesInput.files);
            if (files.length === 0) return;
            ui.setLoadingState(true);
            
            const workerScript = document.getElementById('analysis-worker-script').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            AppState.analysisWorker = new Worker(URL.createObjectURL(workerBlob));
            
            AppState.analysisWorker.onmessage = handleWorkerMessage;
            AppState.analysisWorker.onerror = (e) => {
                ui.appendLog(`워커 오류: ${e.message}`, 'text-red-500');
                ui.setLoadingState(false);
            };

            const file = files[0];
            const options = {
                threshold: parseFloat(D.thresholdSlider.value),
                faceApiUrl: C.MODEL_URL,
                modelUrl: C.MODEL_WEIGHTS_URL,
                detectionCanvasWidth: C.DETECTION_CANVAS_WIDTH,
                fileIndex: 0,
                totalFiles: files.length
            };
            AppState.analysisWorker.postMessage({ file, options });
        }

        function cancelAnalysis() {
            if (AppState.analysisWorker) {
                AppState.analysisWorker.terminate();
                AppState.analysisWorker = null;
                ui.appendLog('사용자에 의해 분석이 중단되었습니다.', 'text-yellow-500');
                ui.setLoadingState(false);
            }
        }
        
        async function handleWorkerMessage(event) {
            const { type, payload } = event.data;
            switch(type) {
                case 'progress': ui.updateAnalysisProgress(payload); break;
                case 'log': ui.appendLog(payload.message, payload.color, 'WORKER'); break;
                case 'result':
                    ui.appendLog('영상 분석 완료. 결과 업로드를 시작합니다.', 'text-green-500');
                    await uploadAnalysisResult(payload);
                    if(AppState.analysisWorker) AppState.analysisWorker.terminate();
                    AppState.analysisWorker = null;
                    ui.setLoadingState(false);
                    break;
                case 'error':
                    ui.appendLog(`분석 워커 오류: ${payload.message}`, 'text-red-500');
                    console.error("Worker error stack:", payload.stack);
                    ui.setLoadingState(false);
                    break;
            }
        }

        async function uploadAnalysisResult(result) {
            const { fileName, frameScores, keyFramesData } = result;
            let framesToUpload = keyFramesData;
            let uploadedKeyFrames = [];
            
            if (framesToUpload.length > 0) {
                 const totalUploads = framesToUpload.length * 4;
                 let completedUploads = 0;
                 for (let i = 0; i < framesToUpload.length; i++) {
                     const kf = framesToUpload[i];
                     const timestamp = `${Date.now()}_${i}`;
                     const basePath = `${C.STORAGE_PATH}/${timestamp}`;
                     
                     const onProgress = () => {
                         completedUploads++;
                         ui.updateUploadProgress(completedUploads / totalUploads);
                     };
                     
                     const [sharpFullUrl, sharpCroppedUrl, blurryFullUrl, blurryCroppedUrl] = await Promise.all([
                         api.uploadFile(`${basePath}_sf.jpeg`, kf.sharpFull).then(url => { onProgress(); return url; }),
                         api.uploadFile(`${basePath}_sc.jpeg`, kf.sharpCropped).then(url => { onProgress(); return url; }),
                         api.uploadFile(`${basePath}_bf.jpeg`, kf.blurryFull).then(url => { onProgress(); return url; }),
                         api.uploadFile(`${basePath}_bc.jpeg`, kf.blurryCropped).then(url => { onProgress(); return url; }),
                     ]);
                     
                     const { sharpFull, sharpCropped, blurryFull, blurryCropped, ...rest } = kf;
                     uploadedKeyFrames.push({ ...rest, sharpFullUrl, sharpCroppedUrl, blurryFullUrl, blurryCroppedUrl });
                 }
            }
            
            const upperFileName = fileName.toUpperCase();
            let table = '기타';
            if (upperFileName.includes('ONYX')) table = 'ONYX';
            else if (upperFileName.includes('DTD')) table = 'DTD';
            else if (upperFileName.includes('LUXON')) table = 'LUXON';

            const newAnalysis = {
                fileName, frameScores, keyFrames: uploadedKeyFrames,
                year: parseInt(D.yearInput.value, 10) || new Date().getFullYear(),
                eventType: D.eventTypeInput.value.trim() || 'N/A',
                day: D.dayInput.value.trim() || 'N/A',
                table,
                correctionCompleted: false
            };
            
            const newDocId = await api.addAnalysis(newAnalysis);
            AppState.lastAddedDocId = newDocId;
            ui.appendLog(`'${fileName}' 분석 결과가 성공적으로 저장되었습니다.`, 'text-green-500');
        }

        async function handleStorageTest() {
            const file = D.testFileInput.files[0];
            ui.appendLog('[CLIENT] Storage 테스트 시작...', 'text-purple-400');
            if (!file) { ui.appendLog('[CLIENT] 파일이 선택되지 않았습니다.', 'text-red-400'); return; }
            if (!Firebase.auth.currentUser) { ui.appendLog('[CLIENT] 인증 정보가 없습니다.', 'text-red-400'); return; }
            
            const storagePath = `${C.TEST_STORAGE_PATH}/${Date.now()}_${file.name}`;
            try {
                const downloadURL = await api.uploadFile(storagePath, file, (progress) => {
                    ui.appendLog(`[SERVER] 진행률: ${Math.round(progress * 100)}%`, 'text-green-500', 'SERVER');
                });
                ui.appendLog('[SERVER] Storage 업로드 성공!', 'text-green-500', 'SERVER');
                ui.appendLog(`[SERVER] URL: ${downloadURL}`, 'text-blue-400', 'SERVER');
            } catch (error) {
                ui.appendLog(`[SERVER] Storage 업로드 실패: ${error.code}`, 'text-red-500', 'SERVER');
            }
        }

        async function handleFirestoreTest() {
            ui.appendLog('[CLIENT] Firestore 테스트 시작...', 'text-yellow-400');
            if (!Firebase.auth.currentUser) { ui.appendLog('[CLIENT] 인증 정보가 없습니다.', 'text-red-400'); return; }
            try {
                const docRef = await addDoc(collection(Firebase.db, C.TEST_FIRESTORE_PATH), {
                    message: "Firestore write test successful!",
                    timestamp: serverTimestamp()
                });
                ui.appendLog(`[SERVER] Firestore 쓰기 성공! (문서 ID: ${docRef.id})`, 'text-green-500', 'SERVER');
            } catch (error) {
                ui.appendLog(`[SERVER] Firestore 쓰기 실패: ${error.code}`, 'text-red-500', 'SERVER');
            }
        }

        window.onload = initialize;
        window.onbeforeunload = () => {
            if (AppState.currentLockedDocId) {
                api.releaseLock(AppState.currentLockedDocId);
            }
        };

    </script>
</body>
</html>
