<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 - v2.8 (카테고리 입력 기능)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; scroll-behavior: smooth; padding-top: 60px; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-item:hover { background-color: #f0f9ff; }
        .result-item.selected { background-color: #dbeafe; border-left: 4px solid #2563eb; }
        .result-item.locked { background-color: #f1f5f9; opacity: 0.6; cursor: not-allowed; }
        .result-item.locked:hover { background-color: #f1f5f9; }
        #custom-modal-overlay, #upload-test-modal-overlay, #review-modal-overlay { background-color: rgba(0, 0, 0, 0.5); }
        .nav-link { transition: all 0.2s ease-in-out; }
        .nav-link:hover { color: #2563eb; transform: translateY(-2px); }
        .filter-select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <nav class="fixed top-0 left-0 right-0 bg-white/80 backdrop-blur-sm shadow-md z-40 h-[60px] flex items-center justify-center">
        <div class="container mx-auto px-4 flex justify-between items-center">
             <h1 class="text-xl md:text-2xl font-bold text-gray-900">
                포커스 이슈 탐지기
                <span id="version-display" class="text-sm align-middle text-blue-600 font-semibold"></span>
            </h1>
            <div class="hidden md:flex items-center space-x-6 font-semibold text-gray-600">
                <a href="#control-panel-section" class="nav-link">1. 제어판</a>
                <a href="#history-section" class="nav-link">2. 분석 기록</a>
                <a href="#details-section" class="nav-link">3. 상세 분석</a>
                <a href="#log-section" class="nav-link">4. 실시간 로그</a>
            </div>
            <div class="flex items-center">
                 <button id="show-upload-test-btn" class="text-sm bg-gray-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-gray-600 transition">연결 테스트</button>
            </div>
        </div>
    </nav>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8 py-4">
            <p id="connection-status" class="text-sm text-gray-500 mt-1">연결 상태: 확인 중...</p>
            <p id="model-status" class="text-sm text-yellow-600 mt-1">인식 모델 로딩 중...</p>
        </header>
        
        <main class="space-y-8">
            <!-- Control Panel -->
            <div id="control-panel-section" class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 제어 패널</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                    <div class="space-y-6">
                        <div>
                            <label for="video-files-input" class="block text-sm font-medium text-gray-700 mb-1">영상 파일 선택</label>
                            <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                        </div>
                         <div class="space-y-2">
                            <label for="threshold-slider" class="block text-sm font-medium text-gray-700">흐림 기준값 (낮을수록 민감)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="threshold-value" contenteditable="true" class="font-bold text-lg text-blue-600 w-16 text-center cursor-text focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md px-1">50</span>
                            </div>
                        </div>
                    </div>
                    <!-- Category Inputs -->
                    <div class="space-y-4 p-4 bg-gray-50 rounded-lg border">
                        <h3 class="text-md font-semibold text-gray-800">분석 정보 입력</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                            <div>
                                <label for="year-input" class="block text-sm font-medium text-gray-700">연도</label>
                                <input type="number" id="year-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="event-type-input" class="block text-sm font-medium text-gray-700">이벤트 종류</label>
                                <input type="text" id="event-type-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                             <div>
                                <label for="day-input" class="block text-sm font-medium text-gray-700">데이</label>
                                <input type="text" id="day-input" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                        </div>
                         <p class="text-xs text-gray-500">'테이블' 정보는 파일명(ONYX, DTD, LUXON)에 따라 자동으로 분류됩니다.</p>
                    </div>
                </div>
                <div class="mt-6">
                    <label for="review-before-upload-checkbox" class="flex items-center text-sm font-medium text-gray-700 cursor-pointer">
                        <input type="checkbox" id="review-before-upload-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                        <span class="ml-2">업로드 전 검토하기</span>
                    </label>
                </div>
                <div class="mt-6 text-center">
                     <button id="analyze-button" class="w-full md:w-auto bg-green-600 text-white font-bold py-3 px-12 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        분석 시작
                    </button>
                    <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center">
                        <div class="flex items-center justify-center space-x-4">
                            <div class="loader"></div>
                            <canvas id="preview-canvas" width="240" height="135" class="hidden bg-gray-200 rounded-md shadow-inner"></canvas>
                        </div>
                        <p id="progress-text" class="text-gray-600 mt-2"></p>
                        <div id="upload-progress-container" class="w-full mt-4 hidden">
                             <div class="w-full bg-gray-200 rounded-full h-4">
                                 <div id="upload-progress-bar" class="bg-blue-600 h-4 rounded-full text-xs font-medium text-white text-center leading-4 transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <button id="cancel-upload-btn" class="hidden mt-4 bg-red-600 text-white font-bold py-2 px-6 rounded-full hover:bg-red-700 transition">
                            분석 중단
                        </button>
                    </div>
                </div>
            </div>

            <!-- Analysis History -->
            <div id="history-section" class="bg-white p-6 rounded-2xl shadow-lg">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 기록</h2>
                 <!-- Filter Controls -->
                 <div id="filter-controls" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4 p-4 bg-gray-50 rounded-lg border">
                    <div>
                        <label for="year-filter" class="block text-sm font-medium text-gray-700">연도</label>
                        <select id="year-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="event-type-filter" class="block text-sm font-medium text-gray-700">이벤트 종류</label>
                        <select id="event-type-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="day-filter" class="block text-sm font-medium text-gray-700">데이</label>
                        <select id="day-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                    <div>
                        <label for="table-filter" class="block text-sm font-medium text-gray-700">테이블</label>
                        <select id="table-filter" class="filter-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                    </div>
                 </div>
                 <div id="results-list-container" class="space-y-1 max-h-[60vh] overflow-y-auto">
                     <p id="results-list-placeholder" class="text-gray-500 text-center py-4">인증이 완료되면 기록을 불러옵니다...</p>
                 </div>
                 <div id="pagination-controls" class="pt-4 mt-4 border-t flex justify-center gap-2"></div>
            </div>

            <!-- Details Section -->
            <div id="details-section" class="hidden space-y-8">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                      <h2 id="details-title" class="text-xl font-semibold mb-4 border-b pb-2 flex justify-between items-center">
                        <span>3. 상세 분석 그래프</span>
                        <button id="export-csv-btn" class="text-sm bg-blue-500 text-white font-semibold py-1 px-3 rounded-full hover:bg-blue-600 transition">CSV로 내보내기</button>
                      </h2>
                      <p class="text-sm text-gray-600 mb-2 -mt-2">그래프 위 빨간 점에 마우스를 올리면 주요 프레임을 확인할 수 있습니다.</p>
                      <div id="chart-container" class="relative h-48 md:h-64">
                          <canvas id="detail-chart"></canvas>
                      </div>
                </div>
                 <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 border-b pb-2">4. 주요 프레임 보기</h2>
                    <div id="key-frames-container" class="space-y-4">
                        <p id="key-frames-placeholder" class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없거나, 아직 기록이 선택되지 않았습니다.</p>
                    </div>
                </div>
            </div>
            
            <!-- Log Container -->
            <div id="log-section" class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">실시간 분석 로그</h2>
                <div id="log-container" class="min-h-[10rem] max-h-[50rem] overflow-y-auto bg-gray-900 text-white font-mono rounded-lg p-4 border text-sm"><p id="log-placeholder" class="text-gray-400 text-center py-4">분석을 시작하거나 과거 기록을 선택하면 로그가 표시됩니다.</p></div>
            </div>
        </main>
    </div>

    <!-- Modals (unchanged from previous version) -->
    <div id="review-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-4xl transform transition-transform duration-300 scale-95 flex flex-col h-[90vh]">
            <div class="flex justify-between items-center mb-4 border-b pb-3">
                <h3 class="text-lg font-bold text-gray-900">업로드 전 검토</h3>
                <button id="close-review-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <p class="text-sm text-gray-600 mb-4">업로드할 문제 프레임을 선택하세요. 선택 해제된 항목은 서버에 저장되지 않습니다.</p>
            <div id="review-frames-list" class="flex-grow overflow-y-auto space-y-4 pr-2"></div>
            <div class="mt-6 flex justify-end space-x-3 border-t pt-4">
                <button id="review-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">전체 취소</button>
                <button id="review-confirm-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">선택한 프레임 업로드</button>
            </div>
        </div>
    </div>
    <div id="upload-test-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="upload-test-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-lg transform transition-transform duration-300 scale-95">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-900">Firebase 연결 테스트</h3>
                <button id="close-test-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <h4 class="font-semibold mb-2">1. Storage 업로드 테스트</h4>
                    <input type="file" id="test-file-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer mb-2"/>
                    <button id="start-storage-test-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700 transition">Storage 테스트 시작</button>
                </div>
                 <div class="border-t my-4"></div>
                <div>
                    <h4 class="font-semibold mb-2">2. Firestore 쓰기 테스트</h4>
                    <button id="start-firestore-test-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-full hover:bg-indigo-700 transition">Firestore 테스트 시작</button>
                </div>
            </div>
        </div>
    </div>
    <div id="custom-modal-overlay" class="hidden fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300">
        <div id="custom-modal" class="bg-white rounded-lg shadow-xl p-6 w-11/12 max-w-md transform transition-transform duration-300 scale-95">
            <h3 id="modal-title" class="text-lg font-bold text-gray-900">확인</h3>
            <p id="modal-message" class="mt-2 text-sm text-gray-600">이 작업을 정말로 수행하시겠습니까?</p>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">취소</button>
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">확인</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase 11.x SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- Constants ---
        const C = {
            APP_VERSION: "2.8",
            FIREBASE_COLLECTION: 'public_data/shared_documents/analyses',
            STORAGE_PATH: 'public_assets',
            TEST_STORAGE_PATH: 'public_assets/test-uploads',
            TEST_FIRESTORE_PATH: 'public_data/shared_documents/test_writes',
            LOCAL_STORAGE_KEY: 'focusThreshold',
            DEFAULT_THRESHOLD: 50,
            LOCK_TIMEOUT_MS: 5 * 60 * 1000, // 5 minutes
            ITEMS_PER_PAGE: 20,
            MODEL_URL: 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights',
            DETECTION_CANVAS_WIDTH: 480, // For performance optimization
        };

        document.title = `포커스 이슈 탐지기 - v${C.APP_VERSION}`;
        document.getElementById('version-display').textContent = `v${C.APP_VERSION}`;
        
        // --- DOM References ---
        const connectionStatus = document.getElementById('connection-status');
        const modelStatus = document.getElementById('model-status');
        const videoFilesInput = document.getElementById('video-files-input');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdValueEl = document.getElementById('threshold-value');
        const reviewBeforeUploadCheckbox = document.getElementById('review-before-upload-checkbox');
        const analyzeButton = document.getElementById('analyze-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressText = document.getElementById('progress-text');
        const uploadProgressContainer = document.getElementById('upload-progress-container');
        const uploadProgressBar = document.getElementById('upload-progress-bar');
        const cancelUploadBtn = document.getElementById('cancel-upload-btn');
        const resultsListContainer = document.getElementById('results-list-container');
        const resultsListPlaceholder = document.getElementById('results-list-placeholder');
        const paginationControls = document.getElementById('pagination-controls');
        const detailsSection = document.getElementById('details-section');
        const detailsTitle = document.getElementById('details-title');
        const detailChartCanvas = document.getElementById('detail-chart');
        const logContainer = document.getElementById('log-container');
        const keyFramesContainer = document.getElementById('key-frames-container');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const showUploadTestBtn = document.getElementById('show-upload-test-btn');
        const uploadTestModalOverlay = document.getElementById('upload-test-modal-overlay');
        const closeTestModalBtn = document.getElementById('close-test-modal-btn');
        const testFileInput = document.getElementById('test-file-input');
        const startStorageTestBtn = document.getElementById('start-storage-test-btn');
        const startFirestoreTestBtn = document.getElementById('start-firestore-test-btn');
        const reviewModalOverlay = document.getElementById('review-modal-overlay');
        const reviewFramesList = document.getElementById('review-frames-list');
        const closeReviewModalBtn = document.getElementById('close-review-modal-btn');
        const reviewCancelBtn = document.getElementById('review-cancel-btn');
        const reviewConfirmBtn = document.getElementById('review-confirm-btn');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const yearFilter = document.getElementById('year-filter');
        const eventTypeFilter = document.getElementById('event-type-filter');
        const dayFilter = document.getElementById('day-filter');
        const tableFilter = document.getElementById('table-filter');
        const yearInput = document.getElementById('year-input');
        const eventTypeInput = document.getElementById('event-type-input');
        const dayInput = document.getElementById('day-input');

        // --- Global State ---
        let videoFiles = [];
        let modelsLoaded = false;
        let allAnalysisData = [];
        let detailChart = null;
        let currentPage = 1;
        let analysisController = null;
        let currentLockedDocId = null;
        let reviewModalObjectUrls = [];
        let filtersApplied = false;

        // --- Firebase State ---
        let app, auth, db, storage;
        let unsubscribeFromAnalyses = null;

        // --- UI & Log Functions ---
        function appendLog(message, colorClass = 'text-gray-400', source = 'APP') {
            if (logContainer.querySelector("#log-placeholder")) logContainer.innerHTML = '';
            const logEntry = document.createElement('div');
            const prefix = `[${source}]`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${prefix} ${message}`;
            logEntry.className = colorClass;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // --- Modal Logic ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modal = document.getElementById('custom-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        let modalResolve = null;
        let reviewModalResolve = null;

        function showConfirmationModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('scale-95'), 10);
            return new Promise(resolve => { modalResolve = resolve; });
        }

        function closeModal(result) {
            modal.classList.add('scale-95');
            setTimeout(() => modalOverlay.classList.add('hidden'), 300);
            if (modalResolve) { modalResolve(result); modalResolve = null; }
        }
        modalCancelBtn.addEventListener('click', () => closeModal(false));
        modalConfirmBtn.addEventListener('click', () => closeModal(true));
        modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) closeModal(false); });

        function handleCloseReviewModal(confirmed) {
            reviewModalOverlay.classList.add('hidden');
            reviewModalObjectUrls.forEach(url => URL.revokeObjectURL(url));
            reviewModalObjectUrls = [];

            if (!reviewModalResolve) return;

            if (!confirmed) {
                reviewModalResolve(null);
            } else {
                const selectedIndices = [];
                reviewFramesList.querySelectorAll('.review-frame-item').forEach(el => {
                    const checkbox = el.querySelector('input[type="checkbox"]');
                    if (checkbox.checked) {
                        selectedIndices.push(parseInt(el.dataset.frameIndex, 10));
                    }
                });
                reviewModalResolve(selectedIndices);
            }
            reviewModalResolve = null;
        }

        async function showReviewModal(keyFrames) {
            reviewFramesList.innerHTML = ''; 
            reviewModalObjectUrls = [];

            for (const frame of keyFrames) {
                const item = document.createElement('div');
                item.className = 'review-frame-item p-3 border rounded-lg bg-gray-50';
                item.dataset.frameIndex = keyFrames.indexOf(frame);

                const sharpFullUrl = URL.createObjectURL(dataURLtoBlob(frame.sharpFull));
                const sharpCroppedUrl = frame.sharpCropped ? URL.createObjectURL(dataURLtoBlob(frame.sharpCropped)) : 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face';
                const blurryFullUrl = URL.createObjectURL(dataURLtoBlob(frame.blurryFull));
                const blurryCroppedUrl = frame.blurryCropped ? URL.createObjectURL(dataURLtoBlob(frame.blurryCropped)) : 'https://placehold.co/300x200/1f2937/4b5563?text=No+Face';

                reviewModalObjectUrls.push(sharpFullUrl, sharpCroppedUrl, blurryFullUrl, blurryCroppedUrl);

                item.innerHTML = `
                    <div class="flex items-start gap-4">
                        <input type="checkbox" id="review-check-${keyFrames.indexOf(frame)}" class="mt-1 h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                        <label for="review-check-${keyFrames.indexOf(frame)}" class="flex-grow cursor-pointer">
                            <p class="font-semibold">문제 감지 @ ${frame.time.toFixed(2)}초</p>
                            <p class="text-xs text-gray-500">이전 프레임 점수: ${frame.sharpScore?.toFixed(2) ?? 'N/A'} &rarr; 문제 프레임 점수: ${frame.blurryScore?.toFixed(2) ?? 'N/A'}</p>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-2">
                                <img src="${sharpFullUrl}" class="w-full rounded border" title="이전 프레임 (전체)">
                                <img src="${sharpCroppedUrl}" class="w-full rounded border" title="이전 프레임 (얼굴)">
                                <img src="${blurryFullUrl}" class="w-full rounded border" title="문제 프레임 (전체)">
                                <img src="${blurryCroppedUrl}" class="w-full rounded border" title="문제 프레임 (얼굴)">
                            </div>
                        </label>
                    </div>
                `;
                reviewFramesList.appendChild(item);
            }

            reviewModalOverlay.classList.remove('hidden');
            return new Promise(resolve => { reviewModalResolve = resolve; });
        }
        closeReviewModalBtn.addEventListener('click', () => handleCloseReviewModal(false));
        reviewCancelBtn.addEventListener('click', () => handleCloseReviewModal(false));
        reviewConfirmBtn.addEventListener('click', () => handleCloseReviewModal(true));

        // --- Locking Mechanism ---
        async function releaseLock(docId) {
            if (!docId) return;
            const docRef = doc(db, C.FIREBASE_COLLECTION, docId);
            try {
                await updateDoc(docRef, { lock: null });
                appendLog(`잠금 해제: ${docId}`, 'text-gray-500');
            } catch (error) {
                console.error(`Failed to release lock for ${docId}:`, error);
            }
        }

        async function releaseCurrentLock() {
            if (currentLockedDocId) {
                await releaseLock(currentLockedDocId);
                currentLockedDocId = null;
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (currentLockedDocId) {
                releaseLock(currentLockedDocId);
            }
        });

        // --- Initialization & Firebase Connection Management ---
        async function startApp() {
            appendLog('앱 시작...', 'text-white');
            
            const firebaseConfig = {
                apiKey: "AIzaSyAyTh3kG9pPcgqcs-MHXSBKFgY_gnRWae0",
                authDomain: "analyze-frame-focus.firebaseapp.com",
                projectId: "analyze-frame-focus",
                storageBucket: "analyze-frame-focus.firebasestorage.app",
                messagingSenderId: "995861796391",
                appId: "1:995861796391:web:549944764ca046594c2002",
                measurementId: "G-8GCL3Z7W9C"
            };
            
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
                
                connectionStatus.textContent = `연결 상태: 연결 성공 (${firebaseConfig.projectId})`;
                connectionStatus.className = 'text-sm text-green-600 mt-1';
                appendLog(`Firebase 연결 성공 (Project: ${firebaseConfig.projectId})`, 'text-green-500');

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        appendLog(`인증 완료 (UID: ${user.uid})`, 'text-green-500');
                        if (unsubscribeFromAnalyses) unsubscribeFromAnalyses();
                        listenForDataChanges();
                    } else {
                        await signInAnonymously(auth);
                    }
                });

            } catch (e) {
                connectionStatus.textContent = '오류: Firebase 초기화 실패.';
                connectionStatus.className = 'text-sm text-red-600 mt-1';
                appendLog(`Firebase 초기화 오류: ${e.message}`, 'text-red-500');
                analyzeButton.disabled = true;
            }

            const savedThreshold = localStorage.getItem(C.LOCAL_STORAGE_KEY) || C.DEFAULT_THRESHOLD;
            updateThreshold(savedThreshold, false);

            await loadFaceApiModels();
        }
        
        async function loadFaceApiModels() {
            if (modelsLoaded) return;
            try {
                await faceapi.nets.ssdMobilenetv1.loadFromUri(C.MODEL_URL);
                modelsLoaded = true;
                modelStatus.textContent = '얼굴 인식 모델 로딩 완료!';
                modelStatus.className = 'text-sm text-green-600 mt-1';
                updateAnalyzeButtonState();
            } catch (error) {
                modelStatus.textContent = '모델 로딩 실패';
                appendLog(`모델 로딩 실패: ${error.message}`, 'text-red-500');
            }
        }
        
        function listenForDataChanges() {
            unsubscribeFromAnalyses = onSnapshot(collection(db, C.FIREBASE_COLLECTION), (snapshot) => {
                const updatePromises = [];
                const migratedData = snapshot.docs.map(docSnap => {
                    const data = docSnap.data();
                    const id = docSnap.id;
                    if (!data.year || !data.table) {
                        const fileName = data.fileName.toUpperCase();
                        let table = '기타';
                        if (fileName.includes('ONYX')) table = 'ONYX';
                        else if (fileName.includes('DTD')) table = 'DTD';
                        else if (fileName.includes('LUXON')) table = 'LUXON';

                        const migrationData = {
                            year: 2025,
                            eventType: 'MAIN EVENT',
                            day: 'DAY 2',
                            table: table
                        };
                        
                        updatePromises.push(updateDoc(doc(db, C.FIREBASE_COLLECTION, id), migrationData));
                        return { id, ...data, ...migrationData };
                    }
                    return { id, ...data };
                });

                if (updatePromises.length > 0) {
                    appendLog(`${updatePromises.length}개의 기록에 카테고리 정보를 추가합니다...`, 'text-blue-400');
                    Promise.all(updatePromises)
                        .then(() => appendLog('모든 기록이 최신 상태로 업데이트되었습니다.', 'text-green-500'))
                        .catch(err => appendLog(`기록 업데이트 중 오류 발생: ${err.message}`, 'text-red-500'));
                }

                allAnalysisData = migratedData;
                allAnalysisData.sort((a, b) => (b.timestamp?.seconds ?? 0) - (a.timestamp?.seconds ?? 0));
                
                populateFilters(allAnalysisData);
                setDefaultCategoryInputs(allAnalysisData);
                renderAnalysisResultsList();

            }, (error) => {
                appendLog(`DB 데이터 수신 오류: ${error.code} - ${error.message}`, 'text-red-500');
            });
        }

        function updateAnalyzeButtonState() { 
            analyzeButton.disabled = videoFiles.length === 0 || !modelsLoaded; 
        }

        function dataURLtoBlob(dataurl) {
            if (!dataurl) return null;
            const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type:mime});
        }

        // --- Core Logic & Render Functions ---
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData;
            if (width === 0 || height === 0) return 0;
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            let laplacianMean = 0;
            const laplacianValues = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;
                    const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                    laplacianValues.push(laplacian);
                    laplacianMean += laplacian;
                }
            }
            if (laplacianValues.length === 0) return 0;
            laplacianMean /= laplacianValues.length;
            const variance = laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
            return variance;
        }

        function getBestFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null;
            if (detections.length === 1) return detections[0];

            const frameCenterX = videoWidth / 2;
            const frameCenterY = videoHeight / 2;

            const scoredDetections = detections.map(detection => {
                const { box } = detection;
                const area = box.width * box.height;
                const faceCenterX = box.x + box.width / 2;
                const faceCenterY = box.y + box.height / 2;
                const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2));
                return { detection, area, distance };
            });

            const maxArea = Math.max(...scoredDetections.map(d => d.area));
            const maxDistance = Math.max(...scoredDetections.map(d => d.distance));
            const safeMaxArea = maxArea === 0 ? 1 : maxArea;
            const safeMaxDistance = maxDistance === 0 ? 1 : maxDistance;

            let bestDetection = null;
            let maxScore = -1;

            for (const item of scoredDetections) {
                const sizeScore = item.area / safeMaxArea;
                const distanceScore = 1 - (item.distance / safeMaxDistance);
                const finalScore = (sizeScore * 0.6) + (distanceScore * 0.4);
                if (finalScore > maxScore) {
                    maxScore = finalScore;
                    bestDetection = item.detection;
                }
            }
            return bestDetection;
        }
        
        function getCroppedFaceDataURL(canvas, box) {
            if (!box) return null;
            const { x, y, width, height } = box;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
            return tempCanvas.toDataURL('image/jpeg', 0.8);
        }

        function populateFilters(data) {
            const populate = (element, values) => {
                const currentValue = element.value;
                element.innerHTML = '<option value="all">전체</option>';
                [...new Set(values)].sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    element.appendChild(option);
                });
                element.value = currentValue || 'all';
            };

            populate(yearFilter, data.map(item => item.year).filter(Boolean));
            populate(eventTypeFilter, data.map(item => item.eventType).filter(Boolean));
            populate(dayFilter, data.map(item => item.day).filter(Boolean));
            populate(tableFilter, data.map(item => item.table).filter(Boolean));
        }

        function setDefaultCategoryInputs(data) {
            if (data.length > 0) {
                const latestEntry = data[0]; // Assuming data is sorted by timestamp desc
                yearInput.value = latestEntry.year || new Date().getFullYear();
                eventTypeInput.value = latestEntry.eventType || 'MAIN EVENT';
                dayInput.value = latestEntry.day || 'DAY 2';
            } else {
                yearInput.value = new Date().getFullYear();
                eventTypeInput.value = 'MAIN EVENT';
                dayInput.value = 'DAY 2';
            }
        }

        function renderAnalysisResultsList() {
            resultsListPlaceholder.classList.add('hidden');
            resultsListContainer.innerHTML = '';
            
            let filteredData = allAnalysisData;

            if (filtersApplied) {
                const yf = yearFilter.value;
                const etf = eventTypeFilter.value;
                const df = dayFilter.value;
                const tf = tableFilter.value;

                filteredData = allAnalysisData.filter(item => {
                    const yearMatch = yf === 'all' || item.year == yf;
                    const eventTypeMatch = etf === 'all' || item.eventType === etf;
                    const dayMatch = df === 'all' || item.day === df;
                    const tableMatch = tf === 'all' || item.table === tf;
                    return yearMatch && eventTypeMatch && dayMatch && tableMatch;
                });
            }

            if (filteredData.length === 0) {
                resultsListPlaceholder.textContent = '선택한 필터에 해당하는 기록이 없습니다.';
                resultsListPlaceholder.classList.remove('hidden');
                paginationControls.innerHTML = '';
                return;
            }

            const totalPages = Math.ceil(filteredData.length / C.ITEMS_PER_PAGE);
            currentPage = Math.min(currentPage, totalPages);
            const startIndex = (currentPage - 1) * C.ITEMS_PER_PAGE;
            const paginatedData = filteredData.slice(startIndex, startIndex + C.ITEMS_PER_PAGE);

            paginatedData.forEach((data) => {
                const item = document.createElement('div');
                const dateString = data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString() : '날짜 없음';
                const problemCount = (data.keyFrames || []).filter(kf => kf.manualOverride !== 'ok').length;
                
                const lock = data.lock;
                const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > C.LOCK_TIMEOUT_MS;
                const isLocked = lock && !isStale;
                const isLockedByCurrentUser = isLocked && lock.lockedBy === auth.currentUser.uid;
                const isLockedByOther = isLocked && !isLockedByCurrentUser;

                item.className = `result-item p-3 border-b flex justify-between items-center transition-colors duration-200`;
                if (isLockedByOther) item.classList.add('locked');
                if (isLockedByCurrentUser || data.id === currentLockedDocId) item.classList.add('selected');

                item.dataset.analysisId = data.id;

                let lockIcon = '';
                if (isLockedByOther) {
                    lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-gray-500 mr-2" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg>`;
                } else if (isLockedByCurrentUser) {
                    lockIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-blue-600 mr-2" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8m1.173-1.173a14.3 14.3 0 0 1 1.66-2.043C4.12 3.4 5.88 2.5 8 2.5s3.879.9 5.168 2.287a14.3 14.3 0 0 1 1.66 2.043A14.3 14.3 0 0 1 16 8s-.9 1.88-2.287 3.173a14.3 14.3 0 0 1-1.66 2.043C11.879 14.6 10.12 15.5 8 15.5s-3.879-.9-5.168-2.287a14.3 14.3 0 0 1-1.66-2.043A14.3 14.3 0 0 1 0 8s.9-1.88 2.287-3.173Z"/></svg>`;
                }
                
                item.innerHTML = `
                    <div class="flex-grow overflow-hidden flex items-center">
                        ${lockIcon}
                        <div>
                            <p class="font-medium text-gray-800 truncate text-sm" title="${data.fileName}">${data.fileName}</p>
                            <p class="text-xs text-gray-500">${dateString}</p>
                        </div>
                    </div>
                    <div class="flex items-center ml-2">
                        <span class="inline-block bg-gray-200 text-gray-800 text-xs font-semibold mr-4 px-2.5 py-0.5 rounded-full">${data.table || 'N/A'}</span>
                        <div class="text-sm font-semibold ${problemCount > 0 ? 'text-red-500' : 'text-green-600'} w-28 text-right">문제 프레임: ${problemCount}개</div>
                        <button class="delete-analysis-button ml-4 text-gray-400 hover:text-red-600 p-2 rounded-full hover:bg-red-100 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" class="pointer-events-none">
                                <path d="M11 1.5v1h3.5a.5.5 0 0 1 0 1h-.538l-.853 10.66A2 2 0 0 1 11.115 16h-6.23a2 2 0 0 1-1.994-1.84L2.038 3.5H1.5a.5.5 0 0 1 0-1H5v-1A1.5 1.5 0 0 1 6.5 0h3A1.5 1.5 0 0 1 11 1.5m-5 0v1h4v-1a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5M4.5 5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06m3.5-.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06"/>
                            </svg>
                        </button>
                    </div>`;
                resultsListContainer.appendChild(item);
            });

            renderPagination(totalPages, filteredData.length);
        }

        resultsListContainer.addEventListener('click', async (e) => {
            const resultItem = e.target.closest('.result-item');
            if (!resultItem) return;

            if (resultItem.classList.contains('locked')) {
                appendLog('다른 사용자가 사용 중인 항목입니다.', 'text-yellow-400');
                return;
            }

            const analysisId = resultItem.dataset.analysisId;

            if (e.target.closest('.delete-analysis-button')) {
                e.stopPropagation();
                handleDeleteAnalysis(analysisId);
                return;
            }

            if (analysisId === currentLockedDocId) return;

            await releaseCurrentLock();
            
            const docRef = doc(db, C.FIREBASE_COLLECTION, analysisId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(docRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";

                    const data = sfDoc.data();
                    const lock = data.lock;
                    const isStale = lock && lock.lockedAt && (Date.now() - lock.lockedAt.toDate().getTime()) > C.LOCK_TIMEOUT_MS;
                    
                    if (lock && !isStale && lock.lockedBy !== auth.currentUser.uid) {
                        throw new Error("다른 사용자가 방금 이 항목을 잠갔습니다.");
                    }

                    transaction.update(docRef, { 
                        lock: {
                            lockedBy: auth.currentUser.uid,
                            lockedAt: serverTimestamp()
                        }
                    });
                });

                currentLockedDocId = analysisId;
                appendLog(`항목 잠금 성공: ${analysisId}`, 'text-green-400');
                renderDetailedViewContent(analysisId);

            } catch (error) {
                appendLog(`항목을 잠글 수 없습니다: ${error.message}`, 'text-red-500');
                console.error("Locking failed: ", error);
            }
        });
        
        function renderPagination(totalPages, totalItems) {
            paginationControls.innerHTML = '';
            if (totalItems <= C.ITEMS_PER_PAGE) return;
            for (let i = 1; i <= totalPages; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = `px-3 py-1 rounded-md text-sm transition-colors ${i === currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`;
                button.onclick = () => { currentPage = i; renderAnalysisResultsList(); };
                paginationControls.appendChild(button);
            }
        }

        function highlightKeyFrame(time) {
            removeKeyFrameHighlight(); 
            const targetElement = document.querySelector(`#key-frames-container > div[data-time="${time}"]`);
            if (targetElement) {
                targetElement.classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function removeKeyFrameHighlight() {
            const highlighted = document.querySelector('.ring-2');
            if (highlighted) {
                highlighted.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
            }
        }

        function renderDetailedViewContent(analysisId) {
            const resultData = allAnalysisData.find(d => d.id === analysisId);
            if (!resultData) {
                detailsSection.classList.add('hidden');
                return;
            };
            detailsSection.classList.remove('hidden');
            detailsTitle.querySelector('span').textContent = `3. 상세 분석: ${resultData.fileName}`;

            if (detailChart) { detailChart.destroy(); }
            
            const frameScores = resultData.frameScores || [];
            const keyFrames = resultData.keyFrames || [];

            const blurryPoints = keyFrames.filter(kf => kf.manualOverride !== 'ok').map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));
            const okPoints = keyFrames.filter(kf => kf.manualOverride === 'ok').map(kf => ({x: kf.time, y: frameScores.find(fs => fs.time === kf.time)?.score || 0}));

            detailChart = new Chart(detailChartCanvas, {
                type: 'line',
                data: {
                    datasets: [
                        { label: '선명도', data: frameScores.map(fs => ({x: fs.time, y: fs.score})), borderColor: 'rgba(59, 130, 246, 0.5)', borderWidth: 1.5, pointRadius: 0, tension: 0.4 },
                        { label: '흐림 감지', data: blurryPoints, backgroundColor: 'rgb(239, 68, 68)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' },
                        { label: '수동 확인 (OK)', data: okPoints, backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter' }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { title: { display: true, text: '선명도 점수' } } },
                    plugins: { legend: { position: 'top' }, tooltip: { enabled: true } },
                    onHover: (event, chartElement) => {
                        const canvas = detailChartCanvas;
                        canvas.style.cursor = 'default';
                        removeKeyFrameHighlight();

                        if (chartElement.length > 0) {
                            const element = chartElement[0];
                            const datasetIndex = element.datasetIndex;
                            const index = element.index;
                            
                            if (datasetIndex === 1 || datasetIndex === 2) {
                                canvas.style.cursor = 'pointer';
                                const timeValue = detailChart.data.datasets[datasetIndex].data[index].x;
                                highlightKeyFrame(timeValue);
                            }
                        }
                    },
                }
            });

            renderKeyFramesForDetail(resultData);
            detailsSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        function renderKeyFramesForDetail(resultData) {
            keyFramesContainer.innerHTML = '';
            const keyFrames = resultData.keyFrames || [];
            
            if (keyFrames.length === 0) {
                keyFramesContainer.innerHTML = `<p class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없습니다.</p>`;
                return;
            }

            keyFrames.sort((a, b) => a.time - b.time).forEach(data => {
                const isOverridden = data.manualOverride === 'ok';
                const sharpScoreText = data.sharpScore !== null && data.sharpScore !== undefined ? data.sharpScore.toFixed(2) : 'N/A';
                const blurryScoreText = data.blurryScore !== null && data.blurryScore !== undefined ? data.blurryScore.toFixed(2) : 'N/A';

                const pairContainer = document.createElement('div');
                pairContainer.className = 'p-4 bg-gray-50 rounded-lg shadow-inner border space-y-4 transition-all duration-300';
                pairContainer.dataset.time = data.time;

                pairContainer.innerHTML = `
                    <h4 class="font-bold text-md">@ ${data.time.toFixed(2)}초</h4>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <p class="text-xs font-semibold text-green-600 mb-1">이전 프레임 (전체) - 점수: ${sharpScoreText}</p>
                            <img src="${data.sharpFullUrl}" class="w-full rounded-md border" loading="lazy">
                            <p class="text-xs font-semibold text-green-600 mt-2 mb-1">이전 프레임 (얼굴)</p>
                            <img src="${data.sharpCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy">
                        </div>
                        <div>
                            <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mb-1">문제 프레임 (전체) - 점수: ${blurryScoreText}</p>
                            <img src="${data.blurryFullUrl}" class="w-full rounded-md border" loading="lazy">
                            <p class="text-xs font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mt-2 mb-1">문제 프레임 (얼굴)</p>
                            <img src="${data.blurryCroppedUrl || 'https://placehold.co/300x200/e2e8f0/475569?text=No+Face'}" class="w-full rounded-md border" loading="lazy">
                        </div>
                    </div>
                    <button data-analysis-id="${resultData.id}" data-time="${data.time}" data-action="ok" class="manual-override-button w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm ${isOverridden ? 'hidden' : ''}">이 프레임은 문제 없음</button>
                    <button data-analysis-id="${resultData.id}" data-time="${data.time}" data-action="problem" class="manual-override-button w-full px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 text-sm ${!isOverridden ? 'hidden' : ''}">문제 프레임으로 되돌리기</button>
                `;
                keyFramesContainer.appendChild(pairContainer);
            });

            keyFramesContainer.querySelectorAll('.manual-override-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const { analysisId, time, action } = e.currentTarget.dataset;
                    handleManualCorrection(analysisId, parseFloat(time), action);
                });
            });
        }

        async function handleManualCorrection(analysisId, time, action) {
            const docRef = doc(db, C.FIREBASE_COLLECTION, analysisId);
            const docData = allAnalysisData.find(d => d.id === analysisId);
            if (!docData) return;

            const updatedKeyFrames = docData.keyFrames.map(kf => {
                if (kf.time === time) {
                    return action === 'ok' ? { ...kf, manualOverride: 'ok' } : (({ manualOverride, ...rest }) => rest)(kf);
                }
                return kf;
            });

            try {
                await updateDoc(docRef, { keyFrames: updatedKeyFrames });
            } catch(err) {
                appendLog(`수동 보정 저장 실패: ${err.message}`, 'text-red-500');
            }
        }

        async function handleDeleteAnalysis(analysisId) {
            const docData = allAnalysisData.find(d => d.id === analysisId);
            if (!docData) return;

            const confirmed = await showConfirmationModal('삭제 확인', `'${docData.fileName}' 기록을 정말 삭제하시겠습니까?`);
            if (!confirmed) return;
            
            try {
                if (currentLockedDocId === analysisId) {
                    currentLockedDocId = null;
                }
                const keyFrames = docData.keyFrames || [];
                const urlsToDelete = keyFrames.flatMap(kf => [kf.sharpFullUrl, kf.sharpCroppedUrl, kf.blurryFullUrl, kf.blurryCroppedUrl]).filter(Boolean);
                const deletePromises = urlsToDelete.map(url => deleteObject(ref(storage, url)));
                await Promise.all(deletePromises);

                await deleteDoc(doc(db, C.FIREBASE_COLLECTION, analysisId));
                
                if (detailChartCanvas.dataset.analysisId === analysisId) {
                    detailsSection.classList.add('hidden');
                }
            } catch(err) {
                appendLog(`기록 삭제 실패: ${err.message}`, 'text-red-500');
            }
        }

        // --- Main Analysis Logic ---
        videoFilesInput.addEventListener('change', (event) => { videoFiles = Array.from(event.target.files); updateAnalyzeButtonState(); });
        
        function updateThreshold(value, save = true) {
            const min = parseInt(thresholdSlider.min, 10);
            const max = parseInt(thresholdSlider.max, 10);
            let clampedValue = parseInt(value, 10);

            if (isNaN(clampedValue)) clampedValue = C.DEFAULT_THRESHOLD;
            clampedValue = Math.max(min, Math.min(max, clampedValue));

            thresholdSlider.value = clampedValue;
            thresholdValueEl.textContent = clampedValue;
            if (save) {
                localStorage.setItem(C.LOCAL_STORAGE_KEY, clampedValue);
            }
        }

        thresholdSlider.addEventListener('input', (event) => updateThreshold(event.target.value));
        thresholdValueEl.addEventListener('blur', (event) => updateThreshold(event.target.textContent));
        thresholdValueEl.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                event.target.blur();
            }
        });
        
        cancelUploadBtn.addEventListener('click', () => {
            if (analysisController) {
                appendLog('사용자가 분석/업로드 중단을 요청했습니다.', 'text-yellow-500');
                analysisController.abort();
            }
        });

        async function uploadWithProgress(storageRef, blob, signal) {
            return new Promise((resolve, reject) => {
                if (!blob) return resolve(null);
                
                const uploadTask = uploadBytesResumable(storageRef, blob);

                const unsubscribe = uploadTask.on('state_changed', 
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        uploadProgressBar.style.width = `${progress}%`;
                    }, 
                    (error) => {
                        unsubscribe();
                        reject(error);
                    }, 
                    async () => {
                        unsubscribe();
                        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                        resolve(downloadURL);
                    }
                );
                
                signal.addEventListener('abort', () => {
                    unsubscribe();
                    uploadTask.cancel();
                });
            });
        }
        
        function setUIForAnalysis(isAnalyzing) {
            if (isAnalyzing) {
                loadingIndicator.style.display = 'flex';
                previewCanvas.classList.remove('hidden');
                analyzeButton.disabled = true;
                cancelUploadBtn.classList.remove('hidden');
                thresholdSlider.disabled = true;
                thresholdValueEl.contentEditable = false;
            } else {
                loadingIndicator.style.display = 'none';
                previewCanvas.classList.add('hidden');
                cancelUploadBtn.classList.add('hidden');
                uploadProgressContainer.classList.add('hidden');
                uploadProgressBar.style.width = '0%';
                analyzeButton.disabled = false;
                thresholdSlider.disabled = false;
                thresholdValueEl.contentEditable = true;
                analysisController = null;
                videoFiles = [];
                videoFilesInput.value = '';
                updateAnalyzeButtonState();
            }
        }

        async function analyzeVideoFile(file, options) {
            const { threshold, signal, yieldToMain } = options;
            
            const analysisVideo = document.createElement('video');
            analysisVideo.crossOrigin = 'anonymous';
            const analysisCanvas = document.createElement('canvas');
            const analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });
            
            const detectionCanvas = document.createElement('canvas');
            const detectionCtx = detectionCanvas.getContext('2d');

            const fileURL = URL.createObjectURL(file);
            analysisVideo.src = fileURL;

            const duration = await new Promise(resolve => {
                analysisVideo.onloadedmetadata = () => resolve(analysisVideo.duration);
            });

            const frameScores = [];
            let previousFrameState = { status: '미검출', fullFrameData: null, croppedFaceData: null, detectionBox: null, score: null };
            const keyFramesData = [];
            const SAMPLING_INTERVAL_SECONDS = 0.5;
            const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);

            for (let j = 0; j < totalSamples; j++) {
                if (signal.aborted) throw new Error("분석이 중단되었습니다.");
                progressText.textContent = `프레임 분석 중... (${options.fileIndex + 1}/${options.totalFiles}) - ${j + 1}/${totalSamples}`;

                const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                await new Promise(resolve => {
                    analysisVideo.onseeked = () => resolve();
                    analysisVideo.currentTime = currentTime;
                });

                if (analysisCanvas.width !== analysisVideo.videoWidth) analysisCanvas.width = analysisVideo.videoWidth;
                if (analysisCanvas.height !== analysisVideo.videoHeight) analysisCanvas.height = analysisVideo.videoHeight;
                analysisCtx.drawImage(analysisVideo, 0, 0, analysisCanvas.width, analysisCanvas.height);
                
                previewCtx.drawImage(analysisCanvas, 0, 0, previewCanvas.width, previewCanvas.height);

                const scale = C.DETECTION_CANVAS_WIDTH / analysisVideo.videoWidth;
                detectionCanvas.width = C.DETECTION_CANVAS_WIDTH;
                detectionCanvas.height = analysisVideo.videoHeight * scale;
                detectionCtx.drawImage(analysisVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);

                const detections = await faceapi.detectAllFaces(detectionCanvas, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 }));
                const resizedDetections = faceapi.resizeResults(detections, { width: analysisCanvas.width, height: analysisCanvas.height });
                const bestFace = getBestFace(resizedDetections, analysisCanvas.width, analysisCanvas.height);

                let currentStatus = '미검출', currentCroppedFace = null, currentDetectionBox = null, currentScore = null;

                if (bestFace) {
                    const { x, y, width, height } = bestFace.box;
                    const faceImageData = analysisCtx.getImageData(x, y, width, height);
                    currentScore = calculateFocusScore(faceImageData);
                    currentStatus = currentScore < threshold ? '흐림' : '선명';
                    frameScores.push({ time: currentTime, score: currentScore });
                    currentCroppedFace = getCroppedFaceDataURL(analysisCanvas, bestFace.box);
                    currentDetectionBox = bestFace.box;
                }

                if (currentStatus === '흐림' && (previousFrameState.status === '선명' || previousFrameState.status === '미검출')) {
                    const blurryFullFrame = analysisCanvas.toDataURL('image/jpeg', 0.8);
                    const data = {
                        time: currentTime,
                        sharpFull: previousFrameState.fullFrameData, sharpCropped: previousFrameState.croppedFaceData,
                        sharpBox: previousFrameState.detectionBox, sharpScore: previousFrameState.score,
                        blurryFull: blurryFullFrame, blurryCropped: currentCroppedFace,
                        blurryBox: currentDetectionBox, blurryScore: currentScore
                    };
                    keyFramesData.push(data);
                    appendLog(`문제 의심 프레임 감지 @ ${currentTime.toFixed(2)}초`, 'text-yellow-400');
                }

                previousFrameState = {
                    status: currentStatus,
                    fullFrameData: analysisCanvas.toDataURL('image/jpeg', 0.8),
                    croppedFaceData: currentCroppedFace,
                    detectionBox: currentDetectionBox,
                    score: currentScore
                };

                await yieldToMain();
            }
            
            URL.revokeObjectURL(fileURL);
            return { fileName: file.name, frameScores, keyFramesData };
        }

        async function uploadAndSaveResults(analysisResult, categoryInfo, signal) {
            const { fileName, frameScores, keyFramesData } = analysisResult;
            let uploadedKeyFrames = [];

            if (keyFramesData.length > 0) {
                let selectedFrameIndices;

                if (reviewBeforeUploadCheckbox.checked) {
                    progressText.textContent = `분석 완료. ${keyFramesData.length}개의 문제 의심 프레임을 검토하세요.`;
                    selectedFrameIndices = await showReviewModal(keyFramesData);
                } else {
                    appendLog('자동 검토 모드로 모든 문제 프레임을 업로드합니다.', 'text-blue-400');
                    selectedFrameIndices = keyFramesData.map((_, index) => index);
                }

                if (selectedFrameIndices === null) throw new Error("사용자가 검토를 취소했습니다.");

                if (selectedFrameIndices.length > 0) {
                    const framesToUpload = selectedFrameIndices.map(index => keyFramesData[index]);
                    uploadProgressContainer.classList.remove('hidden');

                    for (let k = 0; k < framesToUpload.length; k++) {
                        if (signal.aborted) throw new Error("업로드가 중단되었습니다.");

                        const kf = framesToUpload[k];
                        const timestamp = `${Date.now()}_${k}`;
                        const blobs = {
                            sharpFull: dataURLtoBlob(kf.sharpFull), sharpCropped: dataURLtoBlob(kf.sharpCropped),
                            blurryFull: dataURLtoBlob(kf.blurryFull), blurryCropped: dataURLtoBlob(kf.blurryCropped)
                        };
                        const refs = {
                            sharpFull: ref(storage, `${C.STORAGE_PATH}/${timestamp}_sharp_full.jpeg`),
                            sharpCropped: ref(storage, `${C.STORAGE_PATH}/${timestamp}_sharp_crop.jpeg`),
                            blurryFull: ref(storage, `${C.STORAGE_PATH}/${timestamp}_blurry_full.jpeg`),
                            blurryCropped: ref(storage, `${C.STORAGE_PATH}/${timestamp}_blurry_crop.jpeg`)
                        };

                        const progressBase = k * 4;
                        const totalUploads = framesToUpload.length * 4;

                        progressText.textContent = `에셋 업로드 중... (${progressBase + 1}/${totalUploads})`;
                        const sharpFullUrl = await uploadWithProgress(refs.sharpFull, blobs.sharpFull, signal);
                        progressText.textContent = `에셋 업로드 중... (${progressBase + 2}/${totalUploads})`;
                        const sharpCroppedUrl = await uploadWithProgress(refs.sharpCropped, blobs.sharpCropped, signal);
                        progressText.textContent = `에셋 업로드 중... (${progressBase + 3}/${totalUploads})`;
                        const blurryFullUrl = await uploadWithProgress(refs.blurryFull, blobs.blurryFull, signal);
                        progressText.textContent = `에셋 업로드 중... (${progressBase + 4}/${totalUploads})`;
                        const blurryCroppedUrl = await uploadWithProgress(refs.blurryCropped, blobs.blurryCropped, signal);

                        uploadedKeyFrames.push({
                            time: kf.time, sharpFullUrl, sharpCroppedUrl, blurryFullUrl, blurryCroppedUrl,
                            sharpBox: kf.sharpBox, blurryBox: kf.blurryBox,
                            sharpScore: kf.sharpScore, blurryScore: kf.blurryScore
                        });
                    }
                } else {
                    appendLog('업로드할 프레임이 선택되지 않았습니다.', 'text-yellow-500');
                }
            }

            const totalScore = frameScores.reduce((sum, frame) => sum + frame.score, 0);
            const avgScore = frameScores.length > 0 ? totalScore / frameScores.length : 0;
            
            const upperFileName = fileName.toUpperCase();
            let table = '기타';
            if (upperFileName.includes('ONYX')) table = 'ONYX';
            else if (upperFileName.includes('DTD')) table = 'DTD';
            else if (upperFileName.includes('LUXON')) table = 'LUXON';

            const newAnalysis = {
                fileName, timestamp: serverTimestamp(), avgScore,
                problematic: uploadedKeyFrames.length > 0, frameScores, keyFrames: uploadedKeyFrames,
                lock: null,
                year: categoryInfo.year, 
                eventType: categoryInfo.eventType, 
                day: categoryInfo.day, 
                table: table
            };

            const docRef = await addDoc(collection(db, C.FIREBASE_COLLECTION), newAnalysis);
            appendLog(`'${fileName}' 분석 완료 및 결과 저장.`, 'text-green-500');

            setTimeout(async () => {
                await releaseCurrentLock();
                currentLockedDocId = docRef.id;
                renderAnalysisResultsList();
                renderDetailedViewContent(docRef.id);
            }, 500);
        }

        analyzeButton.addEventListener('click', async () => {
            setUIForAnalysis(true);
            analysisController = new AbortController();
            const signal = analysisController.signal;
            const yieldToMain = () => new Promise(resolve => setTimeout(resolve, 0));
            const threshold = parseFloat(thresholdSlider.value);
            const categoryInfo = {
                year: parseInt(yearInput.value, 10) || new Date().getFullYear(),
                eventType: eventTypeInput.value.trim() || 'N/A',
                day: dayInput.value.trim() || 'N/A'
            };

            try {
                for (let i = 0; i < videoFiles.length; i++) {
                    if (signal.aborted) throw new Error("분석이 중단되었습니다.");
                    const file = videoFiles[i];
                    const analysisResult = await analyzeVideoFile(file, {
                        threshold, signal, yieldToMain, fileIndex: i, totalFiles: videoFiles.length
                    });
                    await uploadAndSaveResults(analysisResult, categoryInfo, signal);
                }
            } catch (error) {
                if (error.code === 'storage/canceled' || (error.message && (error.message.includes('canceled') || error.message.includes('중단')))) {
                    appendLog(`분석/업로드 중단됨: ${error.message}`, 'text-yellow-500');
                } else {
                    appendLog(`분석 중 오류 발생: ${error.message}`, 'text-red-500');
                    console.error("Analysis Error Stack:", error.stack);
                }
            } finally {
                setUIForAnalysis(false);
            }
        });

        // --- Event Listeners for Filters ---
        [yearFilter, eventTypeFilter, dayFilter, tableFilter].forEach(filter => {
            filter.addEventListener('change', () => {
                filtersApplied = true;
                currentPage = 1;
                renderAnalysisResultsList();
            });
        });


        // --- Test Modal Logic ---
        showUploadTestBtn.addEventListener('click', () => uploadTestModalOverlay.classList.remove('hidden'));
        closeTestModalBtn.addEventListener('click', () => uploadTestModalOverlay.classList.add('hidden'));
        uploadTestModalOverlay.addEventListener('click', (e) => {
            if (e.target === uploadTestModalOverlay) uploadTestModalOverlay.classList.add('hidden');
        });

        startStorageTestBtn.addEventListener('click', async () => {
            const file = testFileInput.files[0];
            const user = auth.currentUser;
            appendLog('[CLIENT] Storage 테스트 시작...', 'text-purple-400');
            if (!file) { appendLog('[CLIENT] 파일이 선택되지 않았습니다.', 'text-red-400'); return; }
            if (!user) { appendLog('[CLIENT] 인증 정보가 없습니다. 잠시 후 다시 시도하세요.', 'text-red-400'); return; }
            
            const storagePath = `${C.TEST_STORAGE_PATH}/${Date.now()}_${file.name}`;
            const storageRef = ref(storage, storagePath);
            const uploadTask = uploadBytesResumable(storageRef, file);

            uploadTask.on('state_changed',
                (snapshot) => { appendLog(`[SERVER] 진행률: ${Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100)}%`, 'text-green-500', 'SERVER'); },
                (error) => { appendLog(`[SERVER] Storage 업로드 실패: ${error.code}`, 'text-red-500', 'SERVER'); },
                async () => {
                    const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                    appendLog('[SERVER] Storage 업로드 성공!', 'text-green-500', 'SERVER');
                    appendLog(`[SERVER] URL: ${downloadURL}`, 'text-blue-400', 'SERVER');
                }
            );
        });

        startFirestoreTestBtn.addEventListener('click', async () => {
            appendLog('[CLIENT] Firestore 테스트 시작...', 'text-yellow-400');
            if (!auth.currentUser) { appendLog('[CLIENT] 인증 정보가 없습니다.', 'text-red-400'); return; }
            try {
                const docRef = await addDoc(collection(db, C.TEST_FIRESTORE_PATH), {
                    message: "Firestore write test successful!",
                    timestamp: serverTimestamp()
                });
                appendLog(`[SERVER] Firestore 쓰기 성공! (문서 ID: ${docRef.id})`, 'text-green-500', 'SERVER');
            } catch (error) {
                appendLog(`[SERVER] Firestore 쓰기 실패: ${error.code}`, 'text-red-500', 'SERVER');
            }
        });

        window.onload = startApp;

    </script>
</body>
</html>
